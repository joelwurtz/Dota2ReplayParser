<?php
// DO NOT EDIT! Generated by Protobuf-PHP protoc plugin 0.9.4
// Source: dota_usermessages.proto
//   Date: 2012-04-27 16:14:32

namespace  {

  class EDotaUserMessages extends \DrSlump\Protobuf\Enum {
    const DOTA_UM_AddUnitToSelection = 64;
    const DOTA_UM_AIDebugLine = 65;
    const DOTA_UM_ChatEvent = 66;
    const DOTA_UM_CombatHeroPositions = 67;
    const DOTA_UM_CombatLogData = 68;
    const DOTA_UM_CombatLogShowDeath = 70;
    const DOTA_UM_CreateLinearProjectile = 71;
    const DOTA_UM_DestroyLinearProjectile = 72;
    const DOTA_UM_DodgeTrackingProjectiles = 73;
    const DOTA_UM_GlobalLightColor = 74;
    const DOTA_UM_GlobalLightDirection = 75;
    const DOTA_UM_InvalidCommand = 76;
    const DOTA_UM_LocationPing = 77;
    const DOTA_UM_MapLine = 78;
    const DOTA_UM_MiniKillCamInfo = 79;
    const DOTA_UM_MinimapDebugPoint = 80;
    const DOTA_UM_MinimapEvent = 81;
    const DOTA_UM_NevermoreRequiem = 82;
    const DOTA_UM_OverheadEvent = 83;
    const DOTA_UM_SetNextAutobuyItem = 84;
    const DOTA_UM_SharedCooldown = 85;
    const DOTA_UM_SpectatorPlayerClick = 86;
    const DOTA_UM_TutorialTipInfo = 87;
    const DOTA_UM_UnitEvent = 88;
    const DOTA_UM_ParticleManager = 89;
    const DOTA_UM_BotChat = 90;
    const DOTA_UM_HudError = 91;
    const DOTA_UM_ItemPurchased = 92;
    const DOTA_UM_Ping = 93;
    const DOTA_UM_ItemFound = 94;
  }
}
namespace  {

  class DOTA_CHAT_MESSAGE extends \DrSlump\Protobuf\Enum {
    const CHAT_MESSAGE_INVALID = -1;
    const CHAT_MESSAGE_HERO_KILL = 0;
    const CHAT_MESSAGE_HERO_DENY = 1;
    const CHAT_MESSAGE_BARRACKS_KILL = 2;
    const CHAT_MESSAGE_TOWER_KILL = 3;
    const CHAT_MESSAGE_TOWER_DENY = 4;
    const CHAT_MESSAGE_FIRSTBLOOD = 5;
    const CHAT_MESSAGE_STREAK_KILL = 6;
    const CHAT_MESSAGE_BUYBACK = 7;
    const CHAT_MESSAGE_AEGIS = 8;
    const CHAT_MESSAGE_ROSHAN_KILL = 9;
    const CHAT_MESSAGE_COURIER_LOST = 10;
    const CHAT_MESSAGE_COURIER_RESPAWNED = 11;
    const CHAT_MESSAGE_GLYPH_USED = 12;
    const CHAT_MESSAGE_ITEM_PURCHASE = 13;
    const CHAT_MESSAGE_CONNECT = 14;
    const CHAT_MESSAGE_DISCONNECT = 15;
    const CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT = 16;
    const CHAT_MESSAGE_DISCONNECT_TIME_REMAINING = 17;
    const CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL = 18;
    const CHAT_MESSAGE_RECONNECT = 19;
    const CHAT_MESSAGE_ABANDON = 20;
    const CHAT_MESSAGE_SAFE_TO_LEAVE = 21;
    const CHAT_MESSAGE_RUNE_PICKUP = 22;
    const CHAT_MESSAGE_RUNE_BOTTLE = 23;
    const CHAT_MESSAGE_INTHEBAG = 24;
    const CHAT_MESSAGE_SECRETSHOP = 25;
    const CHAT_MESSAGE_ITEM_AUTOPURCHASED = 26;
    const CHAT_MESSAGE_ITEMS_COMBINED = 27;
    const CHAT_MESSAGE_SUPER_CREEPS = 28;
    const CHAT_MESSAGE_CANT_USE_ACTION_ITEM = 29;
    const CHAT_MESSAGE_CHARGES_EXHAUSTED = 30;
    const CHAT_MESSAGE_CANTPAUSE = 31;
    const CHAT_MESSAGE_NOPAUSESLEFT = 32;
    const CHAT_MESSAGE_CANTPAUSEYET = 33;
    const CHAT_MESSAGE_PAUSED = 34;
    const CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 35;
    const CHAT_MESSAGE_UNPAUSED = 36;
    const CHAT_MESSAGE_AUTO_UNPAUSED = 37;
    const CHAT_MESSAGE_YOUPAUSED = 38;
    const CHAT_MESSAGE_CANTUNPAUSETEAM = 39;
    const CHAT_MESSAGE_SAFE_TO_LEAVE_ABANDONER = 40;
    const CHAT_MESSAGE_VOICE_TEXT_BANNED = 41;
    const CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME = 42;
    const CHAT_MESSAGE_REPORT_REMINDER = 43;
    const CHAT_MESSAGE_ECON_ITEM = 44;
    const CHAT_MESSAGE_TAUNT = 45;
    const CHAT_MESSAGE_RANDOM = 46;
    const CHAT_MESSAGE_RD_TURN = 47;
  }
}
namespace  {

  class EDotaEntityMessages extends \DrSlump\Protobuf\Enum {
    const DOTA_UNIT_SPEECH = 0;
    const DOTA_UNIT_SPEECH_MUTE = 1;
    const DOTA_UNIT_ADD_GESTURE = 2;
    const DOTA_UNIT_REMOVE_GESTURE = 3;
    const DOTA_UNIT_REMOVE_ALL_GESTURES = 4;
    const DOTA_UNIT_FADE_GESTURE = 6;
  }
}
namespace  {

  class DOTA_PARTICLE_MESSAGE extends \DrSlump\Protobuf\Enum {
    const DOTA_PARTICLE_MANAGER_EVENT_CREATE = 0;
    const DOTA_PARTICLE_MANAGER_EVENT_UPDATE = 1;
    const DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD = 2;
    const DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION = 3;
    const DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK = 4;
    const DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENT = 5;
    const DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET = 6;
    const DOTA_PARTICLE_MANAGER_EVENT_DESTROY = 7;
    const DOTA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING = 8;
    const DOTA_PARTICLE_MANAGER_EVENT_RELEASE = 9;
    const DOTA_PARTICLE_MANAGER_EVENT_LATENCY = 10;
  }
}
namespace  {

  class DOTA_OVERHEAD_ALERT extends \DrSlump\Protobuf\Enum {
    const OVERHEAD_ALERT_GOLD = 0;
    const OVERHEAD_ALERT_DENY = 1;
    const OVERHEAD_ALERT_CRITICAL = 2;
    const OVERHEAD_ALERT_XP = 3;
    const OVERHEAD_ALERT_BONUS_SPELL_DAMAGE = 4;
    const OVERHEAD_ALERT_MISS = 5;
    const OVERHEAD_ALERT_DAMAGE = 6;
    const OVERHEAD_ALERT_EVADE = 7;
    const OVERHEAD_ALERT_BLOCK = 8;
    const OVERHEAD_ALERT_BONUS_POISON_DAMAGE = 9;
  }
}
namespace  {

  class CDOTAUserMsg_AIDebugLine extends \DrSlump\Protobuf\Message {

    /**  @var string */
    public $message = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_AIDebugLine');

      // OPTIONAL STRING message = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "message";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <message> has a value
     *
     * @return boolean
     */
    public function hasMessage(){
      return $this->_has(1);
    }
    
    /**
     * Clear <message> value
     *
     * @return \CDOTAUserMsg_AIDebugLine
     */
    public function clearMessage(){
      return $this->_clear(1);
    }
    
    /**
     * Get <message> value
     *
     * @return string
     */
    public function getMessage(){
      return $this->_get(1);
    }
    
    /**
     * Set <message> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_AIDebugLine
     */
    public function setMessage( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_Ping extends \DrSlump\Protobuf\Message {

    /**  @var string */
    public $message = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_Ping');

      // OPTIONAL STRING message = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "message";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <message> has a value
     *
     * @return boolean
     */
    public function hasMessage(){
      return $this->_has(1);
    }
    
    /**
     * Clear <message> value
     *
     * @return \CDOTAUserMsg_Ping
     */
    public function clearMessage(){
      return $this->_clear(1);
    }
    
    /**
     * Get <message> value
     *
     * @return string
     */
    public function getMessage(){
      return $this->_get(1);
    }
    
    /**
     * Set <message> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_Ping
     */
    public function setMessage( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_ChatEvent extends \DrSlump\Protobuf\Message {

    /**  @var int - \DOTA_CHAT_MESSAGE */
    public $type = null;
    
    /**  @var int */
    public $value = null;
    
    /**  @var int */
    public $playerid_1 = -1;
    
    /**  @var int */
    public $playerid_2 = -1;
    
    /**  @var int */
    public $playerid_3 = -1;
    
    /**  @var int */
    public $playerid_4 = -1;
    
    /**  @var int */
    public $playerid_5 = -1;
    
    /**  @var int */
    public $playerid_6 = -1;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ChatEvent');

      // REQUIRED ENUM type = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_REQUIRED;
      $f->reference = '\DOTA_CHAT_MESSAGE';
      $descriptor->addField($f);

      // OPTIONAL UINT32 value = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "value";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL SINT32 playerid_1 = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "playerid_1";
      $f->type      = \DrSlump\Protobuf::TYPE_SINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = -1;
      $descriptor->addField($f);

      // OPTIONAL SINT32 playerid_2 = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "playerid_2";
      $f->type      = \DrSlump\Protobuf::TYPE_SINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = -1;
      $descriptor->addField($f);

      // OPTIONAL SINT32 playerid_3 = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "playerid_3";
      $f->type      = \DrSlump\Protobuf::TYPE_SINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = -1;
      $descriptor->addField($f);

      // OPTIONAL SINT32 playerid_4 = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "playerid_4";
      $f->type      = \DrSlump\Protobuf::TYPE_SINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = -1;
      $descriptor->addField($f);

      // OPTIONAL SINT32 playerid_5 = 7
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 7;
      $f->name      = "playerid_5";
      $f->type      = \DrSlump\Protobuf::TYPE_SINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = -1;
      $descriptor->addField($f);

      // OPTIONAL SINT32 playerid_6 = 8
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 8;
      $f->name      = "playerid_6";
      $f->type      = \DrSlump\Protobuf::TYPE_SINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = -1;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <type> has a value
     *
     * @return boolean
     */
    public function hasType(){
      return $this->_has(1);
    }
    
    /**
     * Clear <type> value
     *
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function clearType(){
      return $this->_clear(1);
    }
    
    /**
     * Get <type> value
     *
     * @return int - \DOTA_CHAT_MESSAGE
     */
    public function getType(){
      return $this->_get(1);
    }
    
    /**
     * Set <type> value
     *
     * @param int - \DOTA_CHAT_MESSAGE $value
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function setType( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <value> has a value
     *
     * @return boolean
     */
    public function hasValue(){
      return $this->_has(2);
    }
    
    /**
     * Clear <value> value
     *
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function clearValue(){
      return $this->_clear(2);
    }
    
    /**
     * Get <value> value
     *
     * @return int
     */
    public function getValue(){
      return $this->_get(2);
    }
    
    /**
     * Set <value> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function setValue( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <playerid_1> has a value
     *
     * @return boolean
     */
    public function hasPlayerid1(){
      return $this->_has(3);
    }
    
    /**
     * Clear <playerid_1> value
     *
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function clearPlayerid1(){
      return $this->_clear(3);
    }
    
    /**
     * Get <playerid_1> value
     *
     * @return int
     */
    public function getPlayerid1(){
      return $this->_get(3);
    }
    
    /**
     * Set <playerid_1> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function setPlayerid1( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <playerid_2> has a value
     *
     * @return boolean
     */
    public function hasPlayerid2(){
      return $this->_has(4);
    }
    
    /**
     * Clear <playerid_2> value
     *
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function clearPlayerid2(){
      return $this->_clear(4);
    }
    
    /**
     * Get <playerid_2> value
     *
     * @return int
     */
    public function getPlayerid2(){
      return $this->_get(4);
    }
    
    /**
     * Set <playerid_2> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function setPlayerid2( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <playerid_3> has a value
     *
     * @return boolean
     */
    public function hasPlayerid3(){
      return $this->_has(5);
    }
    
    /**
     * Clear <playerid_3> value
     *
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function clearPlayerid3(){
      return $this->_clear(5);
    }
    
    /**
     * Get <playerid_3> value
     *
     * @return int
     */
    public function getPlayerid3(){
      return $this->_get(5);
    }
    
    /**
     * Set <playerid_3> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function setPlayerid3( $value){
      return $this->_set(5, $value);
    }
    
    /**
     * Check if <playerid_4> has a value
     *
     * @return boolean
     */
    public function hasPlayerid4(){
      return $this->_has(6);
    }
    
    /**
     * Clear <playerid_4> value
     *
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function clearPlayerid4(){
      return $this->_clear(6);
    }
    
    /**
     * Get <playerid_4> value
     *
     * @return int
     */
    public function getPlayerid4(){
      return $this->_get(6);
    }
    
    /**
     * Set <playerid_4> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function setPlayerid4( $value){
      return $this->_set(6, $value);
    }
    
    /**
     * Check if <playerid_5> has a value
     *
     * @return boolean
     */
    public function hasPlayerid5(){
      return $this->_has(7);
    }
    
    /**
     * Clear <playerid_5> value
     *
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function clearPlayerid5(){
      return $this->_clear(7);
    }
    
    /**
     * Get <playerid_5> value
     *
     * @return int
     */
    public function getPlayerid5(){
      return $this->_get(7);
    }
    
    /**
     * Set <playerid_5> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function setPlayerid5( $value){
      return $this->_set(7, $value);
    }
    
    /**
     * Check if <playerid_6> has a value
     *
     * @return boolean
     */
    public function hasPlayerid6(){
      return $this->_has(8);
    }
    
    /**
     * Clear <playerid_6> value
     *
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function clearPlayerid6(){
      return $this->_clear(8);
    }
    
    /**
     * Get <playerid_6> value
     *
     * @return int
     */
    public function getPlayerid6(){
      return $this->_get(8);
    }
    
    /**
     * Set <playerid_6> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ChatEvent
     */
    public function setPlayerid6( $value){
      return $this->_set(8, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_CombatLogData extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $type = null;
    
    /**  @var int */
    public $target_name = null;
    
    /**  @var int */
    public $attacker_name = null;
    
    /**  @var boolean */
    public $attacker_illusion = null;
    
    /**  @var boolean */
    public $target_illusion = null;
    
    /**  @var int */
    public $inflictor_name = null;
    
    /**  @var int */
    public $value = null;
    
    /**  @var int */
    public $health = null;
    
    /**  @var float */
    public $time = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_CombatLogData');

      // OPTIONAL UINT32 type = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "type";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL UINT32 target_name = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "target_name";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL UINT32 attacker_name = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "attacker_name";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL BOOL attacker_illusion = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "attacker_illusion";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL BOOL target_illusion = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "target_illusion";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL UINT32 inflictor_name = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "inflictor_name";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 value = 7
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 7;
      $f->name      = "value";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 health = 8
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 8;
      $f->name      = "health";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL FLOAT time = 9
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 9;
      $f->name      = "time";
      $f->type      = \DrSlump\Protobuf::TYPE_FLOAT;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <type> has a value
     *
     * @return boolean
     */
    public function hasType(){
      return $this->_has(1);
    }
    
    /**
     * Clear <type> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearType(){
      return $this->_clear(1);
    }
    
    /**
     * Get <type> value
     *
     * @return int
     */
    public function getType(){
      return $this->_get(1);
    }
    
    /**
     * Set <type> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setType( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <target_name> has a value
     *
     * @return boolean
     */
    public function hasTargetName(){
      return $this->_has(2);
    }
    
    /**
     * Clear <target_name> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearTargetName(){
      return $this->_clear(2);
    }
    
    /**
     * Get <target_name> value
     *
     * @return int
     */
    public function getTargetName(){
      return $this->_get(2);
    }
    
    /**
     * Set <target_name> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setTargetName( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <attacker_name> has a value
     *
     * @return boolean
     */
    public function hasAttackerName(){
      return $this->_has(3);
    }
    
    /**
     * Clear <attacker_name> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearAttackerName(){
      return $this->_clear(3);
    }
    
    /**
     * Get <attacker_name> value
     *
     * @return int
     */
    public function getAttackerName(){
      return $this->_get(3);
    }
    
    /**
     * Set <attacker_name> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setAttackerName( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <attacker_illusion> has a value
     *
     * @return boolean
     */
    public function hasAttackerIllusion(){
      return $this->_has(4);
    }
    
    /**
     * Clear <attacker_illusion> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearAttackerIllusion(){
      return $this->_clear(4);
    }
    
    /**
     * Get <attacker_illusion> value
     *
     * @return boolean
     */
    public function getAttackerIllusion(){
      return $this->_get(4);
    }
    
    /**
     * Set <attacker_illusion> value
     *
     * @param boolean $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setAttackerIllusion( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <target_illusion> has a value
     *
     * @return boolean
     */
    public function hasTargetIllusion(){
      return $this->_has(5);
    }
    
    /**
     * Clear <target_illusion> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearTargetIllusion(){
      return $this->_clear(5);
    }
    
    /**
     * Get <target_illusion> value
     *
     * @return boolean
     */
    public function getTargetIllusion(){
      return $this->_get(5);
    }
    
    /**
     * Set <target_illusion> value
     *
     * @param boolean $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setTargetIllusion( $value){
      return $this->_set(5, $value);
    }
    
    /**
     * Check if <inflictor_name> has a value
     *
     * @return boolean
     */
    public function hasInflictorName(){
      return $this->_has(6);
    }
    
    /**
     * Clear <inflictor_name> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearInflictorName(){
      return $this->_clear(6);
    }
    
    /**
     * Get <inflictor_name> value
     *
     * @return int
     */
    public function getInflictorName(){
      return $this->_get(6);
    }
    
    /**
     * Set <inflictor_name> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setInflictorName( $value){
      return $this->_set(6, $value);
    }
    
    /**
     * Check if <value> has a value
     *
     * @return boolean
     */
    public function hasValue(){
      return $this->_has(7);
    }
    
    /**
     * Clear <value> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearValue(){
      return $this->_clear(7);
    }
    
    /**
     * Get <value> value
     *
     * @return int
     */
    public function getValue(){
      return $this->_get(7);
    }
    
    /**
     * Set <value> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setValue( $value){
      return $this->_set(7, $value);
    }
    
    /**
     * Check if <health> has a value
     *
     * @return boolean
     */
    public function hasHealth(){
      return $this->_has(8);
    }
    
    /**
     * Clear <health> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearHealth(){
      return $this->_clear(8);
    }
    
    /**
     * Get <health> value
     *
     * @return int
     */
    public function getHealth(){
      return $this->_get(8);
    }
    
    /**
     * Set <health> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setHealth( $value){
      return $this->_set(8, $value);
    }
    
    /**
     * Check if <time> has a value
     *
     * @return boolean
     */
    public function hasTime(){
      return $this->_has(9);
    }
    
    /**
     * Clear <time> value
     *
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function clearTime(){
      return $this->_clear(9);
    }
    
    /**
     * Get <time> value
     *
     * @return float
     */
    public function getTime(){
      return $this->_get(9);
    }
    
    /**
     * Set <time> value
     *
     * @param float $value
     * @return \CDOTAUserMsg_CombatLogData
     */
    public function setTime( $value){
      return $this->_set(9, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_CombatLogShowDeath extends \DrSlump\Protobuf\Message {


    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_CombatLogShowDeath');

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }
  }
}

namespace  {

  class CDOTAUserMsg_BotChat extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $player_id = null;
    
    /**  @var string */
    public $format = null;
    
    /**  @var string */
    public $message = null;
    
    /**  @var string */
    public $target = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_BotChat');

      // OPTIONAL UINT32 player_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "player_id";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL STRING format = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "format";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL STRING message = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "message";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL STRING target = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "target";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <player_id> has a value
     *
     * @return boolean
     */
    public function hasPlayerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <player_id> value
     *
     * @return \CDOTAUserMsg_BotChat
     */
    public function clearPlayerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <player_id> value
     *
     * @return int
     */
    public function getPlayerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <player_id> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_BotChat
     */
    public function setPlayerId( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <format> has a value
     *
     * @return boolean
     */
    public function hasFormat(){
      return $this->_has(2);
    }
    
    /**
     * Clear <format> value
     *
     * @return \CDOTAUserMsg_BotChat
     */
    public function clearFormat(){
      return $this->_clear(2);
    }
    
    /**
     * Get <format> value
     *
     * @return string
     */
    public function getFormat(){
      return $this->_get(2);
    }
    
    /**
     * Set <format> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_BotChat
     */
    public function setFormat( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <message> has a value
     *
     * @return boolean
     */
    public function hasMessage(){
      return $this->_has(3);
    }
    
    /**
     * Clear <message> value
     *
     * @return \CDOTAUserMsg_BotChat
     */
    public function clearMessage(){
      return $this->_clear(3);
    }
    
    /**
     * Get <message> value
     *
     * @return string
     */
    public function getMessage(){
      return $this->_get(3);
    }
    
    /**
     * Set <message> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_BotChat
     */
    public function setMessage( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <target> has a value
     *
     * @return boolean
     */
    public function hasTarget(){
      return $this->_has(4);
    }
    
    /**
     * Clear <target> value
     *
     * @return \CDOTAUserMsg_BotChat
     */
    public function clearTarget(){
      return $this->_clear(4);
    }
    
    /**
     * Get <target> value
     *
     * @return string
     */
    public function getTarget(){
      return $this->_get(4);
    }
    
    /**
     * Set <target> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_BotChat
     */
    public function setTarget( $value){
      return $this->_set(4, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_CombatHeroPositions extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $index = null;
    
    /**  @var int */
    public $time = null;
    
    /**  @var \CMsgVector2D */
    public $world_pos = null;
    
    /**  @var int */
    public $health = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_CombatHeroPositions');

      // OPTIONAL UINT32 index = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "index";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 time = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "time";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE world_pos = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "world_pos";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector2D';
      $descriptor->addField($f);

      // OPTIONAL INT32 health = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "health";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <index> has a value
     *
     * @return boolean
     */
    public function hasIndex(){
      return $this->_has(1);
    }
    
    /**
     * Clear <index> value
     *
     * @return \CDOTAUserMsg_CombatHeroPositions
     */
    public function clearIndex(){
      return $this->_clear(1);
    }
    
    /**
     * Get <index> value
     *
     * @return int
     */
    public function getIndex(){
      return $this->_get(1);
    }
    
    /**
     * Set <index> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatHeroPositions
     */
    public function setIndex( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <time> has a value
     *
     * @return boolean
     */
    public function hasTime(){
      return $this->_has(2);
    }
    
    /**
     * Clear <time> value
     *
     * @return \CDOTAUserMsg_CombatHeroPositions
     */
    public function clearTime(){
      return $this->_clear(2);
    }
    
    /**
     * Get <time> value
     *
     * @return int
     */
    public function getTime(){
      return $this->_get(2);
    }
    
    /**
     * Set <time> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatHeroPositions
     */
    public function setTime( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <world_pos> has a value
     *
     * @return boolean
     */
    public function hasWorldPos(){
      return $this->_has(3);
    }
    
    /**
     * Clear <world_pos> value
     *
     * @return \CDOTAUserMsg_CombatHeroPositions
     */
    public function clearWorldPos(){
      return $this->_clear(3);
    }
    
    /**
     * Get <world_pos> value
     *
     * @return \CMsgVector2D
     */
    public function getWorldPos(){
      return $this->_get(3);
    }
    
    /**
     * Set <world_pos> value
     *
     * @param \CMsgVector2D $value
     * @return \CDOTAUserMsg_CombatHeroPositions
     */
    public function setWorldPos(\CMsgVector2D $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <health> has a value
     *
     * @return boolean
     */
    public function hasHealth(){
      return $this->_has(4);
    }
    
    /**
     * Clear <health> value
     *
     * @return \CDOTAUserMsg_CombatHeroPositions
     */
    public function clearHealth(){
      return $this->_clear(4);
    }
    
    /**
     * Get <health> value
     *
     * @return int
     */
    public function getHealth(){
      return $this->_get(4);
    }
    
    /**
     * Set <health> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CombatHeroPositions
     */
    public function setHealth( $value){
      return $this->_set(4, $value);
    }
  }
}

namespace CDOTAUserMsg_MiniKillCamInfo\Attacker {

  class Ability extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $ability = null;
    
    /**  @var int */
    public $damage = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability');

      // OPTIONAL UINT32 ability = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "ability";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 damage = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "damage";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <ability> has a value
     *
     * @return boolean
     */
    public function hasAbility(){
      return $this->_has(1);
    }
    
    /**
     * Clear <ability> value
     *
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability
     */
    public function clearAbility(){
      return $this->_clear(1);
    }
    
    /**
     * Get <ability> value
     *
     * @return int
     */
    public function getAbility(){
      return $this->_get(1);
    }
    
    /**
     * Set <ability> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability
     */
    public function setAbility( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <damage> has a value
     *
     * @return boolean
     */
    public function hasDamage(){
      return $this->_has(2);
    }
    
    /**
     * Clear <damage> value
     *
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability
     */
    public function clearDamage(){
      return $this->_clear(2);
    }
    
    /**
     * Get <damage> value
     *
     * @return int
     */
    public function getDamage(){
      return $this->_get(2);
    }
    
    /**
     * Set <damage> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability
     */
    public function setDamage( $value){
      return $this->_set(2, $value);
    }
  }
}

namespace CDOTAUserMsg_MiniKillCamInfo {

  class Attacker extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $attacker = null;
    
    /**  @var int */
    public $total_damage = null;
    
    /**  @var \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability[]  */
    public $abilities = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_MiniKillCamInfo.Attacker');

      // OPTIONAL UINT32 attacker = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "attacker";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 total_damage = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "total_damage";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED MESSAGE abilities = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "abilities";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <attacker> has a value
     *
     * @return boolean
     */
    public function hasAttacker(){
      return $this->_has(1);
    }
    
    /**
     * Clear <attacker> value
     *
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker
     */
    public function clearAttacker(){
      return $this->_clear(1);
    }
    
    /**
     * Get <attacker> value
     *
     * @return int
     */
    public function getAttacker(){
      return $this->_get(1);
    }
    
    /**
     * Set <attacker> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker
     */
    public function setAttacker( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <total_damage> has a value
     *
     * @return boolean
     */
    public function hasTotalDamage(){
      return $this->_has(2);
    }
    
    /**
     * Clear <total_damage> value
     *
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker
     */
    public function clearTotalDamage(){
      return $this->_clear(2);
    }
    
    /**
     * Get <total_damage> value
     *
     * @return int
     */
    public function getTotalDamage(){
      return $this->_get(2);
    }
    
    /**
     * Set <total_damage> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker
     */
    public function setTotalDamage( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <abilities> has a value
     *
     * @return boolean
     */
    public function hasAbilities(){
      return $this->_has(3);
    }
    
    /**
     * Clear <abilities> value
     *
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker
     */
    public function clearAbilities(){
      return $this->_clear(3);
    }
    
    /**
     * Get <abilities> value
     *
     * @param int $idx
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability
     */
    public function getAbilities($idx = NULL){
      return $this->_get(3, $idx);
    }
    
    /**
     * Set <abilities> value
     *
     * @param \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability $value
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker
     */
    public function setAbilities(\CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability $value, $idx = NULL){
      return $this->_set(3, $value, $idx);
    }
    
    /**
     * Get all elements of <abilities>
     *
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability[]
     */
    public function getAbilitiesList(){
     return $this->_get(3);
    }
    
    /**
     * Add a new element to <abilities>
     *
     * @param \CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability $value
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker
     */
    public function addAbilities(\CDOTAUserMsg_MiniKillCamInfo\Attacker\Ability $value){
     return $this->_add(3, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_MiniKillCamInfo extends \DrSlump\Protobuf\Message {

    /**  @var \CDOTAUserMsg_MiniKillCamInfo\Attacker[]  */
    public $attackers = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_MiniKillCamInfo');

      // REPEATED MESSAGE attackers = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "attackers";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\CDOTAUserMsg_MiniKillCamInfo\Attacker';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <attackers> has a value
     *
     * @return boolean
     */
    public function hasAttackers(){
      return $this->_has(1);
    }
    
    /**
     * Clear <attackers> value
     *
     * @return \CDOTAUserMsg_MiniKillCamInfo
     */
    public function clearAttackers(){
      return $this->_clear(1);
    }
    
    /**
     * Get <attackers> value
     *
     * @param int $idx
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker
     */
    public function getAttackers($idx = NULL){
      return $this->_get(1, $idx);
    }
    
    /**
     * Set <attackers> value
     *
     * @param \CDOTAUserMsg_MiniKillCamInfo\Attacker $value
     * @return \CDOTAUserMsg_MiniKillCamInfo
     */
    public function setAttackers(\CDOTAUserMsg_MiniKillCamInfo\Attacker $value, $idx = NULL){
      return $this->_set(1, $value, $idx);
    }
    
    /**
     * Get all elements of <attackers>
     *
     * @return \CDOTAUserMsg_MiniKillCamInfo\Attacker[]
     */
    public function getAttackersList(){
     return $this->_get(1);
    }
    
    /**
     * Add a new element to <attackers>
     *
     * @param \CDOTAUserMsg_MiniKillCamInfo\Attacker $value
     * @return \CDOTAUserMsg_MiniKillCamInfo
     */
    public function addAttackers(\CDOTAUserMsg_MiniKillCamInfo\Attacker $value){
     return $this->_add(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_GlobalLightColor extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $color = null;
    
    /**  @var float */
    public $duration = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_GlobalLightColor');

      // OPTIONAL UINT32 color = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "color";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL FLOAT duration = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "duration";
      $f->type      = \DrSlump\Protobuf::TYPE_FLOAT;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <color> has a value
     *
     * @return boolean
     */
    public function hasColor(){
      return $this->_has(1);
    }
    
    /**
     * Clear <color> value
     *
     * @return \CDOTAUserMsg_GlobalLightColor
     */
    public function clearColor(){
      return $this->_clear(1);
    }
    
    /**
     * Get <color> value
     *
     * @return int
     */
    public function getColor(){
      return $this->_get(1);
    }
    
    /**
     * Set <color> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_GlobalLightColor
     */
    public function setColor( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <duration> has a value
     *
     * @return boolean
     */
    public function hasDuration(){
      return $this->_has(2);
    }
    
    /**
     * Clear <duration> value
     *
     * @return \CDOTAUserMsg_GlobalLightColor
     */
    public function clearDuration(){
      return $this->_clear(2);
    }
    
    /**
     * Get <duration> value
     *
     * @return float
     */
    public function getDuration(){
      return $this->_get(2);
    }
    
    /**
     * Set <duration> value
     *
     * @param float $value
     * @return \CDOTAUserMsg_GlobalLightColor
     */
    public function setDuration( $value){
      return $this->_set(2, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_GlobalLightDirection extends \DrSlump\Protobuf\Message {

    /**  @var \CMsgVector */
    public $direction = null;
    
    /**  @var float */
    public $duration = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_GlobalLightDirection');

      // OPTIONAL MESSAGE direction = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "direction";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      // OPTIONAL FLOAT duration = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "duration";
      $f->type      = \DrSlump\Protobuf::TYPE_FLOAT;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <direction> has a value
     *
     * @return boolean
     */
    public function hasDirection(){
      return $this->_has(1);
    }
    
    /**
     * Clear <direction> value
     *
     * @return \CDOTAUserMsg_GlobalLightDirection
     */
    public function clearDirection(){
      return $this->_clear(1);
    }
    
    /**
     * Get <direction> value
     *
     * @return \CMsgVector
     */
    public function getDirection(){
      return $this->_get(1);
    }
    
    /**
     * Set <direction> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_GlobalLightDirection
     */
    public function setDirection(\CMsgVector $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <duration> has a value
     *
     * @return boolean
     */
    public function hasDuration(){
      return $this->_has(2);
    }
    
    /**
     * Clear <duration> value
     *
     * @return \CDOTAUserMsg_GlobalLightDirection
     */
    public function clearDuration(){
      return $this->_clear(2);
    }
    
    /**
     * Get <duration> value
     *
     * @return float
     */
    public function getDuration(){
      return $this->_get(2);
    }
    
    /**
     * Set <duration> value
     *
     * @param float $value
     * @return \CDOTAUserMsg_GlobalLightDirection
     */
    public function setDuration( $value){
      return $this->_set(2, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_LocationPing extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $player_id = null;
    
    /**  @var \CDOTAMsg_LocationPing */
    public $location_ping = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_LocationPing');

      // OPTIONAL UINT32 player_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "player_id";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE location_ping = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "location_ping";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAMsg_LocationPing';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <player_id> has a value
     *
     * @return boolean
     */
    public function hasPlayerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <player_id> value
     *
     * @return \CDOTAUserMsg_LocationPing
     */
    public function clearPlayerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <player_id> value
     *
     * @return int
     */
    public function getPlayerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <player_id> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_LocationPing
     */
    public function setPlayerId( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <location_ping> has a value
     *
     * @return boolean
     */
    public function hasLocationPing(){
      return $this->_has(2);
    }
    
    /**
     * Clear <location_ping> value
     *
     * @return \CDOTAUserMsg_LocationPing
     */
    public function clearLocationPing(){
      return $this->_clear(2);
    }
    
    /**
     * Get <location_ping> value
     *
     * @return \CDOTAMsg_LocationPing
     */
    public function getLocationPing(){
      return $this->_get(2);
    }
    
    /**
     * Set <location_ping> value
     *
     * @param \CDOTAMsg_LocationPing $value
     * @return \CDOTAUserMsg_LocationPing
     */
    public function setLocationPing(\CDOTAMsg_LocationPing $value){
      return $this->_set(2, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_MinimapEvent extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $event_type = null;
    
    /**  @var int */
    public $entity_handle = null;
    
    /**  @var int */
    public $x = null;
    
    /**  @var int */
    public $y = null;
    
    /**  @var int */
    public $duration = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_MinimapEvent');

      // OPTIONAL INT32 event_type = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "event_type";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 entity_handle = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "entity_handle";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 x = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "x";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 y = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "y";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 duration = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "duration";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <event_type> has a value
     *
     * @return boolean
     */
    public function hasEventType(){
      return $this->_has(1);
    }
    
    /**
     * Clear <event_type> value
     *
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function clearEventType(){
      return $this->_clear(1);
    }
    
    /**
     * Get <event_type> value
     *
     * @return int
     */
    public function getEventType(){
      return $this->_get(1);
    }
    
    /**
     * Set <event_type> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function setEventType( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <entity_handle> has a value
     *
     * @return boolean
     */
    public function hasEntityHandle(){
      return $this->_has(2);
    }
    
    /**
     * Clear <entity_handle> value
     *
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function clearEntityHandle(){
      return $this->_clear(2);
    }
    
    /**
     * Get <entity_handle> value
     *
     * @return int
     */
    public function getEntityHandle(){
      return $this->_get(2);
    }
    
    /**
     * Set <entity_handle> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function setEntityHandle( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <x> has a value
     *
     * @return boolean
     */
    public function hasX(){
      return $this->_has(3);
    }
    
    /**
     * Clear <x> value
     *
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function clearX(){
      return $this->_clear(3);
    }
    
    /**
     * Get <x> value
     *
     * @return int
     */
    public function getX(){
      return $this->_get(3);
    }
    
    /**
     * Set <x> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function setX( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <y> has a value
     *
     * @return boolean
     */
    public function hasY(){
      return $this->_has(4);
    }
    
    /**
     * Clear <y> value
     *
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function clearY(){
      return $this->_clear(4);
    }
    
    /**
     * Get <y> value
     *
     * @return int
     */
    public function getY(){
      return $this->_get(4);
    }
    
    /**
     * Set <y> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function setY( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <duration> has a value
     *
     * @return boolean
     */
    public function hasDuration(){
      return $this->_has(5);
    }
    
    /**
     * Clear <duration> value
     *
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function clearDuration(){
      return $this->_clear(5);
    }
    
    /**
     * Get <duration> value
     *
     * @return int
     */
    public function getDuration(){
      return $this->_get(5);
    }
    
    /**
     * Set <duration> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MinimapEvent
     */
    public function setDuration( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_MapLine extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $player_id = null;
    
    /**  @var \CDOTAMsg_MapLine */
    public $mapline = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_MapLine');

      // OPTIONAL INT32 player_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "player_id";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE mapline = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "mapline";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAMsg_MapLine';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <player_id> has a value
     *
     * @return boolean
     */
    public function hasPlayerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <player_id> value
     *
     * @return \CDOTAUserMsg_MapLine
     */
    public function clearPlayerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <player_id> value
     *
     * @return int
     */
    public function getPlayerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <player_id> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MapLine
     */
    public function setPlayerId( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <mapline> has a value
     *
     * @return boolean
     */
    public function hasMapline(){
      return $this->_has(2);
    }
    
    /**
     * Clear <mapline> value
     *
     * @return \CDOTAUserMsg_MapLine
     */
    public function clearMapline(){
      return $this->_clear(2);
    }
    
    /**
     * Get <mapline> value
     *
     * @return \CDOTAMsg_MapLine
     */
    public function getMapline(){
      return $this->_get(2);
    }
    
    /**
     * Set <mapline> value
     *
     * @param \CDOTAMsg_MapLine $value
     * @return \CDOTAUserMsg_MapLine
     */
    public function setMapline(\CDOTAMsg_MapLine $value){
      return $this->_set(2, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_MinimapDebugPoint extends \DrSlump\Protobuf\Message {

    /**  @var \CMsgVector */
    public $location = null;
    
    /**  @var int */
    public $color = null;
    
    /**  @var int */
    public $size = null;
    
    /**  @var float */
    public $duration = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_MinimapDebugPoint');

      // OPTIONAL MESSAGE location = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "location";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      // OPTIONAL UINT32 color = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "color";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 size = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "size";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL FLOAT duration = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "duration";
      $f->type      = \DrSlump\Protobuf::TYPE_FLOAT;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <location> has a value
     *
     * @return boolean
     */
    public function hasLocation(){
      return $this->_has(1);
    }
    
    /**
     * Clear <location> value
     *
     * @return \CDOTAUserMsg_MinimapDebugPoint
     */
    public function clearLocation(){
      return $this->_clear(1);
    }
    
    /**
     * Get <location> value
     *
     * @return \CMsgVector
     */
    public function getLocation(){
      return $this->_get(1);
    }
    
    /**
     * Set <location> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_MinimapDebugPoint
     */
    public function setLocation(\CMsgVector $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <color> has a value
     *
     * @return boolean
     */
    public function hasColor(){
      return $this->_has(2);
    }
    
    /**
     * Clear <color> value
     *
     * @return \CDOTAUserMsg_MinimapDebugPoint
     */
    public function clearColor(){
      return $this->_clear(2);
    }
    
    /**
     * Get <color> value
     *
     * @return int
     */
    public function getColor(){
      return $this->_get(2);
    }
    
    /**
     * Set <color> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MinimapDebugPoint
     */
    public function setColor( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <size> has a value
     *
     * @return boolean
     */
    public function hasSize(){
      return $this->_has(3);
    }
    
    /**
     * Clear <size> value
     *
     * @return \CDOTAUserMsg_MinimapDebugPoint
     */
    public function clearSize(){
      return $this->_clear(3);
    }
    
    /**
     * Get <size> value
     *
     * @return int
     */
    public function getSize(){
      return $this->_get(3);
    }
    
    /**
     * Set <size> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_MinimapDebugPoint
     */
    public function setSize( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <duration> has a value
     *
     * @return boolean
     */
    public function hasDuration(){
      return $this->_has(4);
    }
    
    /**
     * Clear <duration> value
     *
     * @return \CDOTAUserMsg_MinimapDebugPoint
     */
    public function clearDuration(){
      return $this->_clear(4);
    }
    
    /**
     * Get <duration> value
     *
     * @return float
     */
    public function getDuration(){
      return $this->_get(4);
    }
    
    /**
     * Set <duration> value
     *
     * @param float $value
     * @return \CDOTAUserMsg_MinimapDebugPoint
     */
    public function setDuration( $value){
      return $this->_set(4, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_CreateLinearProjectile extends \DrSlump\Protobuf\Message {

    /**  @var \CMsgVector */
    public $origin = null;
    
    /**  @var \CMsgVector2D */
    public $velocity = null;
    
    /**  @var int */
    public $latency = null;
    
    /**  @var int */
    public $entindex = null;
    
    /**  @var int */
    public $particle_index = null;
    
    /**  @var int */
    public $handle = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_CreateLinearProjectile');

      // OPTIONAL MESSAGE origin = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "origin";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE velocity = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "velocity";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector2D';
      $descriptor->addField($f);

      // OPTIONAL INT32 latency = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "latency";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 entindex = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "entindex";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 particle_index = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "particle_index";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 handle = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "handle";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <origin> has a value
     *
     * @return boolean
     */
    public function hasOrigin(){
      return $this->_has(1);
    }
    
    /**
     * Clear <origin> value
     *
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function clearOrigin(){
      return $this->_clear(1);
    }
    
    /**
     * Get <origin> value
     *
     * @return \CMsgVector
     */
    public function getOrigin(){
      return $this->_get(1);
    }
    
    /**
     * Set <origin> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function setOrigin(\CMsgVector $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <velocity> has a value
     *
     * @return boolean
     */
    public function hasVelocity(){
      return $this->_has(2);
    }
    
    /**
     * Clear <velocity> value
     *
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function clearVelocity(){
      return $this->_clear(2);
    }
    
    /**
     * Get <velocity> value
     *
     * @return \CMsgVector2D
     */
    public function getVelocity(){
      return $this->_get(2);
    }
    
    /**
     * Set <velocity> value
     *
     * @param \CMsgVector2D $value
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function setVelocity(\CMsgVector2D $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <latency> has a value
     *
     * @return boolean
     */
    public function hasLatency(){
      return $this->_has(3);
    }
    
    /**
     * Clear <latency> value
     *
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function clearLatency(){
      return $this->_clear(3);
    }
    
    /**
     * Get <latency> value
     *
     * @return int
     */
    public function getLatency(){
      return $this->_get(3);
    }
    
    /**
     * Set <latency> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function setLatency( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <entindex> has a value
     *
     * @return boolean
     */
    public function hasEntindex(){
      return $this->_has(4);
    }
    
    /**
     * Clear <entindex> value
     *
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function clearEntindex(){
      return $this->_clear(4);
    }
    
    /**
     * Get <entindex> value
     *
     * @return int
     */
    public function getEntindex(){
      return $this->_get(4);
    }
    
    /**
     * Set <entindex> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function setEntindex( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <particle_index> has a value
     *
     * @return boolean
     */
    public function hasParticleIndex(){
      return $this->_has(5);
    }
    
    /**
     * Clear <particle_index> value
     *
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function clearParticleIndex(){
      return $this->_clear(5);
    }
    
    /**
     * Get <particle_index> value
     *
     * @return int
     */
    public function getParticleIndex(){
      return $this->_get(5);
    }
    
    /**
     * Set <particle_index> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function setParticleIndex( $value){
      return $this->_set(5, $value);
    }
    
    /**
     * Check if <handle> has a value
     *
     * @return boolean
     */
    public function hasHandle(){
      return $this->_has(6);
    }
    
    /**
     * Clear <handle> value
     *
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function clearHandle(){
      return $this->_clear(6);
    }
    
    /**
     * Get <handle> value
     *
     * @return int
     */
    public function getHandle(){
      return $this->_get(6);
    }
    
    /**
     * Set <handle> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_CreateLinearProjectile
     */
    public function setHandle( $value){
      return $this->_set(6, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_DestroyLinearProjectile extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $handle = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_DestroyLinearProjectile');

      // OPTIONAL INT32 handle = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "handle";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <handle> has a value
     *
     * @return boolean
     */
    public function hasHandle(){
      return $this->_has(1);
    }
    
    /**
     * Clear <handle> value
     *
     * @return \CDOTAUserMsg_DestroyLinearProjectile
     */
    public function clearHandle(){
      return $this->_clear(1);
    }
    
    /**
     * Get <handle> value
     *
     * @return int
     */
    public function getHandle(){
      return $this->_get(1);
    }
    
    /**
     * Set <handle> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_DestroyLinearProjectile
     */
    public function setHandle( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_DodgeTrackingProjectiles extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $entindex = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_DodgeTrackingProjectiles');

      // REQUIRED INT32 entindex = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "entindex";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_REQUIRED;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <entindex> has a value
     *
     * @return boolean
     */
    public function hasEntindex(){
      return $this->_has(1);
    }
    
    /**
     * Clear <entindex> value
     *
     * @return \CDOTAUserMsg_DodgeTrackingProjectiles
     */
    public function clearEntindex(){
      return $this->_clear(1);
    }
    
    /**
     * Get <entindex> value
     *
     * @return int
     */
    public function getEntindex(){
      return $this->_get(1);
    }
    
    /**
     * Set <entindex> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_DodgeTrackingProjectiles
     */
    public function setEntindex( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_SpectatorPlayerClick extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $entindex = null;
    
    /**  @var int */
    public $order_type = null;
    
    /**  @var int */
    public $target_index = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_SpectatorPlayerClick');

      // REQUIRED INT32 entindex = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "entindex";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_REQUIRED;
      $descriptor->addField($f);

      // OPTIONAL INT32 order_type = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "order_type";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 target_index = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "target_index";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <entindex> has a value
     *
     * @return boolean
     */
    public function hasEntindex(){
      return $this->_has(1);
    }
    
    /**
     * Clear <entindex> value
     *
     * @return \CDOTAUserMsg_SpectatorPlayerClick
     */
    public function clearEntindex(){
      return $this->_clear(1);
    }
    
    /**
     * Get <entindex> value
     *
     * @return int
     */
    public function getEntindex(){
      return $this->_get(1);
    }
    
    /**
     * Set <entindex> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_SpectatorPlayerClick
     */
    public function setEntindex( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <order_type> has a value
     *
     * @return boolean
     */
    public function hasOrderType(){
      return $this->_has(2);
    }
    
    /**
     * Clear <order_type> value
     *
     * @return \CDOTAUserMsg_SpectatorPlayerClick
     */
    public function clearOrderType(){
      return $this->_clear(2);
    }
    
    /**
     * Get <order_type> value
     *
     * @return int
     */
    public function getOrderType(){
      return $this->_get(2);
    }
    
    /**
     * Set <order_type> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_SpectatorPlayerClick
     */
    public function setOrderType( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <target_index> has a value
     *
     * @return boolean
     */
    public function hasTargetIndex(){
      return $this->_has(3);
    }
    
    /**
     * Clear <target_index> value
     *
     * @return \CDOTAUserMsg_SpectatorPlayerClick
     */
    public function clearTargetIndex(){
      return $this->_clear(3);
    }
    
    /**
     * Get <target_index> value
     *
     * @return int
     */
    public function getTargetIndex(){
      return $this->_get(3);
    }
    
    /**
     * Set <target_index> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_SpectatorPlayerClick
     */
    public function setTargetIndex( $value){
      return $this->_set(3, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_NevermoreRequiem extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $entity_handle = null;
    
    /**  @var int */
    public $lines = null;
    
    /**  @var \CMsgVector */
    public $origin = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_NevermoreRequiem');

      // OPTIONAL INT32 entity_handle = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "entity_handle";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 lines = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "lines";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE origin = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "origin";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <entity_handle> has a value
     *
     * @return boolean
     */
    public function hasEntityHandle(){
      return $this->_has(1);
    }
    
    /**
     * Clear <entity_handle> value
     *
     * @return \CDOTAUserMsg_NevermoreRequiem
     */
    public function clearEntityHandle(){
      return $this->_clear(1);
    }
    
    /**
     * Get <entity_handle> value
     *
     * @return int
     */
    public function getEntityHandle(){
      return $this->_get(1);
    }
    
    /**
     * Set <entity_handle> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_NevermoreRequiem
     */
    public function setEntityHandle( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <lines> has a value
     *
     * @return boolean
     */
    public function hasLines(){
      return $this->_has(2);
    }
    
    /**
     * Clear <lines> value
     *
     * @return \CDOTAUserMsg_NevermoreRequiem
     */
    public function clearLines(){
      return $this->_clear(2);
    }
    
    /**
     * Get <lines> value
     *
     * @return int
     */
    public function getLines(){
      return $this->_get(2);
    }
    
    /**
     * Set <lines> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_NevermoreRequiem
     */
    public function setLines( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <origin> has a value
     *
     * @return boolean
     */
    public function hasOrigin(){
      return $this->_has(3);
    }
    
    /**
     * Clear <origin> value
     *
     * @return \CDOTAUserMsg_NevermoreRequiem
     */
    public function clearOrigin(){
      return $this->_clear(3);
    }
    
    /**
     * Get <origin> value
     *
     * @return \CMsgVector
     */
    public function getOrigin(){
      return $this->_get(3);
    }
    
    /**
     * Set <origin> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_NevermoreRequiem
     */
    public function setOrigin(\CMsgVector $value){
      return $this->_set(3, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_InvalidCommand extends \DrSlump\Protobuf\Message {

    /**  @var string */
    public $message = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_InvalidCommand');

      // OPTIONAL STRING message = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "message";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <message> has a value
     *
     * @return boolean
     */
    public function hasMessage(){
      return $this->_has(1);
    }
    
    /**
     * Clear <message> value
     *
     * @return \CDOTAUserMsg_InvalidCommand
     */
    public function clearMessage(){
      return $this->_clear(1);
    }
    
    /**
     * Get <message> value
     *
     * @return string
     */
    public function getMessage(){
      return $this->_get(1);
    }
    
    /**
     * Set <message> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_InvalidCommand
     */
    public function setMessage( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_HudError extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $order_id = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_HudError');

      // OPTIONAL INT32 order_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "order_id";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <order_id> has a value
     *
     * @return boolean
     */
    public function hasOrderId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <order_id> value
     *
     * @return \CDOTAUserMsg_HudError
     */
    public function clearOrderId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <order_id> value
     *
     * @return int
     */
    public function getOrderId(){
      return $this->_get(1);
    }
    
    /**
     * Set <order_id> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_HudError
     */
    public function setOrderId( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_SharedCooldown extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $entindex = null;
    
    /**  @var string */
    public $name = null;
    
    /**  @var float */
    public $cooldown = null;
    
    /**  @var int */
    public $name_index = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_SharedCooldown');

      // OPTIONAL INT32 entindex = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "entindex";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL STRING name = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "name";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL FLOAT cooldown = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "cooldown";
      $f->type      = \DrSlump\Protobuf::TYPE_FLOAT;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 name_index = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "name_index";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <entindex> has a value
     *
     * @return boolean
     */
    public function hasEntindex(){
      return $this->_has(1);
    }
    
    /**
     * Clear <entindex> value
     *
     * @return \CDOTAUserMsg_SharedCooldown
     */
    public function clearEntindex(){
      return $this->_clear(1);
    }
    
    /**
     * Get <entindex> value
     *
     * @return int
     */
    public function getEntindex(){
      return $this->_get(1);
    }
    
    /**
     * Set <entindex> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_SharedCooldown
     */
    public function setEntindex( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <name> has a value
     *
     * @return boolean
     */
    public function hasName(){
      return $this->_has(2);
    }
    
    /**
     * Clear <name> value
     *
     * @return \CDOTAUserMsg_SharedCooldown
     */
    public function clearName(){
      return $this->_clear(2);
    }
    
    /**
     * Get <name> value
     *
     * @return string
     */
    public function getName(){
      return $this->_get(2);
    }
    
    /**
     * Set <name> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_SharedCooldown
     */
    public function setName( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <cooldown> has a value
     *
     * @return boolean
     */
    public function hasCooldown(){
      return $this->_has(3);
    }
    
    /**
     * Clear <cooldown> value
     *
     * @return \CDOTAUserMsg_SharedCooldown
     */
    public function clearCooldown(){
      return $this->_clear(3);
    }
    
    /**
     * Get <cooldown> value
     *
     * @return float
     */
    public function getCooldown(){
      return $this->_get(3);
    }
    
    /**
     * Set <cooldown> value
     *
     * @param float $value
     * @return \CDOTAUserMsg_SharedCooldown
     */
    public function setCooldown( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <name_index> has a value
     *
     * @return boolean
     */
    public function hasNameIndex(){
      return $this->_has(4);
    }
    
    /**
     * Clear <name_index> value
     *
     * @return \CDOTAUserMsg_SharedCooldown
     */
    public function clearNameIndex(){
      return $this->_clear(4);
    }
    
    /**
     * Get <name_index> value
     *
     * @return int
     */
    public function getNameIndex(){
      return $this->_get(4);
    }
    
    /**
     * Set <name_index> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_SharedCooldown
     */
    public function setNameIndex( $value){
      return $this->_set(4, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_SetNextAutobuyItem extends \DrSlump\Protobuf\Message {

    /**  @var string */
    public $name = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_SetNextAutobuyItem');

      // OPTIONAL STRING name = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "name";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <name> has a value
     *
     * @return boolean
     */
    public function hasName(){
      return $this->_has(1);
    }
    
    /**
     * Clear <name> value
     *
     * @return \CDOTAUserMsg_SetNextAutobuyItem
     */
    public function clearName(){
      return $this->_clear(1);
    }
    
    /**
     * Get <name> value
     *
     * @return string
     */
    public function getName(){
      return $this->_get(1);
    }
    
    /**
     * Set <name> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_SetNextAutobuyItem
     */
    public function setName( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace CDOTAUserMsg_UnitEvent {

  class Speech extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $concept = null;
    
    /**  @var string */
    public $response = null;
    
    /**  @var int */
    public $recipient_type = null;
    
    /**  @var int */
    public $level = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_UnitEvent.Speech');

      // OPTIONAL INT32 concept = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "concept";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL STRING response = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "response";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 recipient_type = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "recipient_type";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 level = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "level";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <concept> has a value
     *
     * @return boolean
     */
    public function hasConcept(){
      return $this->_has(1);
    }
    
    /**
     * Clear <concept> value
     *
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function clearConcept(){
      return $this->_clear(1);
    }
    
    /**
     * Get <concept> value
     *
     * @return int
     */
    public function getConcept(){
      return $this->_get(1);
    }
    
    /**
     * Set <concept> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function setConcept( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <response> has a value
     *
     * @return boolean
     */
    public function hasResponse(){
      return $this->_has(2);
    }
    
    /**
     * Clear <response> value
     *
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function clearResponse(){
      return $this->_clear(2);
    }
    
    /**
     * Get <response> value
     *
     * @return string
     */
    public function getResponse(){
      return $this->_get(2);
    }
    
    /**
     * Set <response> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function setResponse( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <recipient_type> has a value
     *
     * @return boolean
     */
    public function hasRecipientType(){
      return $this->_has(3);
    }
    
    /**
     * Clear <recipient_type> value
     *
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function clearRecipientType(){
      return $this->_clear(3);
    }
    
    /**
     * Get <recipient_type> value
     *
     * @return int
     */
    public function getRecipientType(){
      return $this->_get(3);
    }
    
    /**
     * Set <recipient_type> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function setRecipientType( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <level> has a value
     *
     * @return boolean
     */
    public function hasLevel(){
      return $this->_has(4);
    }
    
    /**
     * Clear <level> value
     *
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function clearLevel(){
      return $this->_clear(4);
    }
    
    /**
     * Get <level> value
     *
     * @return int
     */
    public function getLevel(){
      return $this->_get(4);
    }
    
    /**
     * Set <level> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function setLevel( $value){
      return $this->_set(4, $value);
    }
  }
}

namespace CDOTAUserMsg_UnitEvent {

  class SpeechMute extends \DrSlump\Protobuf\Message {

    /**  @var float */
    public $delay = 0.5;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_UnitEvent.SpeechMute');

      // OPTIONAL FLOAT delay = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "delay";
      $f->type      = \DrSlump\Protobuf::TYPE_FLOAT;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = 0.5;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <delay> has a value
     *
     * @return boolean
     */
    public function hasDelay(){
      return $this->_has(1);
    }
    
    /**
     * Clear <delay> value
     *
     * @return \CDOTAUserMsg_UnitEvent\SpeechMute
     */
    public function clearDelay(){
      return $this->_clear(1);
    }
    
    /**
     * Get <delay> value
     *
     * @return float
     */
    public function getDelay(){
      return $this->_get(1);
    }
    
    /**
     * Set <delay> value
     *
     * @param float $value
     * @return \CDOTAUserMsg_UnitEvent\SpeechMute
     */
    public function setDelay( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace CDOTAUserMsg_UnitEvent {

  class AddGesture extends \DrSlump\Protobuf\Message {

    /**  @var int - \Activity */
    public $activity = null;
    
    /**  @var int */
    public $slot = null;
    
    /**  @var float */
    public $fade_in = 0;
    
    /**  @var float */
    public $fade_out = 0.1;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_UnitEvent.AddGesture');

      // OPTIONAL ENUM activity = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "activity";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\Activity';
      $descriptor->addField($f);

      // OPTIONAL INT32 slot = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "slot";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL FLOAT fade_in = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "fade_in";
      $f->type      = \DrSlump\Protobuf::TYPE_FLOAT;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = 0;
      $descriptor->addField($f);

      // OPTIONAL FLOAT fade_out = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "fade_out";
      $f->type      = \DrSlump\Protobuf::TYPE_FLOAT;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->default   = 0.1;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <activity> has a value
     *
     * @return boolean
     */
    public function hasActivity(){
      return $this->_has(1);
    }
    
    /**
     * Clear <activity> value
     *
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function clearActivity(){
      return $this->_clear(1);
    }
    
    /**
     * Get <activity> value
     *
     * @return int - \Activity
     */
    public function getActivity(){
      return $this->_get(1);
    }
    
    /**
     * Set <activity> value
     *
     * @param int - \Activity $value
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function setActivity( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <slot> has a value
     *
     * @return boolean
     */
    public function hasSlot(){
      return $this->_has(2);
    }
    
    /**
     * Clear <slot> value
     *
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function clearSlot(){
      return $this->_clear(2);
    }
    
    /**
     * Get <slot> value
     *
     * @return int
     */
    public function getSlot(){
      return $this->_get(2);
    }
    
    /**
     * Set <slot> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function setSlot( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <fade_in> has a value
     *
     * @return boolean
     */
    public function hasFadeIn(){
      return $this->_has(3);
    }
    
    /**
     * Clear <fade_in> value
     *
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function clearFadeIn(){
      return $this->_clear(3);
    }
    
    /**
     * Get <fade_in> value
     *
     * @return float
     */
    public function getFadeIn(){
      return $this->_get(3);
    }
    
    /**
     * Set <fade_in> value
     *
     * @param float $value
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function setFadeIn( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <fade_out> has a value
     *
     * @return boolean
     */
    public function hasFadeOut(){
      return $this->_has(4);
    }
    
    /**
     * Clear <fade_out> value
     *
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function clearFadeOut(){
      return $this->_clear(4);
    }
    
    /**
     * Get <fade_out> value
     *
     * @return float
     */
    public function getFadeOut(){
      return $this->_get(4);
    }
    
    /**
     * Set <fade_out> value
     *
     * @param float $value
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function setFadeOut( $value){
      return $this->_set(4, $value);
    }
  }
}

namespace CDOTAUserMsg_UnitEvent {

  class RemoveGesture extends \DrSlump\Protobuf\Message {

    /**  @var int - \Activity */
    public $activity = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_UnitEvent.RemoveGesture');

      // OPTIONAL ENUM activity = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "activity";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\Activity';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <activity> has a value
     *
     * @return boolean
     */
    public function hasActivity(){
      return $this->_has(1);
    }
    
    /**
     * Clear <activity> value
     *
     * @return \CDOTAUserMsg_UnitEvent\RemoveGesture
     */
    public function clearActivity(){
      return $this->_clear(1);
    }
    
    /**
     * Get <activity> value
     *
     * @return int - \Activity
     */
    public function getActivity(){
      return $this->_get(1);
    }
    
    /**
     * Set <activity> value
     *
     * @param int - \Activity $value
     * @return \CDOTAUserMsg_UnitEvent\RemoveGesture
     */
    public function setActivity( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace CDOTAUserMsg_UnitEvent {

  class BloodImpact extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $scale = null;
    
    /**  @var int */
    public $x_normal = null;
    
    /**  @var int */
    public $y_normal = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_UnitEvent.BloodImpact');

      // OPTIONAL INT32 scale = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "scale";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 x_normal = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "x_normal";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 y_normal = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "y_normal";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <scale> has a value
     *
     * @return boolean
     */
    public function hasScale(){
      return $this->_has(1);
    }
    
    /**
     * Clear <scale> value
     *
     * @return \CDOTAUserMsg_UnitEvent\BloodImpact
     */
    public function clearScale(){
      return $this->_clear(1);
    }
    
    /**
     * Get <scale> value
     *
     * @return int
     */
    public function getScale(){
      return $this->_get(1);
    }
    
    /**
     * Set <scale> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_UnitEvent\BloodImpact
     */
    public function setScale( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <x_normal> has a value
     *
     * @return boolean
     */
    public function hasXNormal(){
      return $this->_has(2);
    }
    
    /**
     * Clear <x_normal> value
     *
     * @return \CDOTAUserMsg_UnitEvent\BloodImpact
     */
    public function clearXNormal(){
      return $this->_clear(2);
    }
    
    /**
     * Get <x_normal> value
     *
     * @return int
     */
    public function getXNormal(){
      return $this->_get(2);
    }
    
    /**
     * Set <x_normal> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_UnitEvent\BloodImpact
     */
    public function setXNormal( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <y_normal> has a value
     *
     * @return boolean
     */
    public function hasYNormal(){
      return $this->_has(3);
    }
    
    /**
     * Clear <y_normal> value
     *
     * @return \CDOTAUserMsg_UnitEvent\BloodImpact
     */
    public function clearYNormal(){
      return $this->_clear(3);
    }
    
    /**
     * Get <y_normal> value
     *
     * @return int
     */
    public function getYNormal(){
      return $this->_get(3);
    }
    
    /**
     * Set <y_normal> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_UnitEvent\BloodImpact
     */
    public function setYNormal( $value){
      return $this->_set(3, $value);
    }
  }
}

namespace CDOTAUserMsg_UnitEvent {

  class FadeGesture extends \DrSlump\Protobuf\Message {

    /**  @var int - \Activity */
    public $activity = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_UnitEvent.FadeGesture');

      // OPTIONAL ENUM activity = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "activity";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\Activity';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <activity> has a value
     *
     * @return boolean
     */
    public function hasActivity(){
      return $this->_has(1);
    }
    
    /**
     * Clear <activity> value
     *
     * @return \CDOTAUserMsg_UnitEvent\FadeGesture
     */
    public function clearActivity(){
      return $this->_clear(1);
    }
    
    /**
     * Get <activity> value
     *
     * @return int - \Activity
     */
    public function getActivity(){
      return $this->_get(1);
    }
    
    /**
     * Set <activity> value
     *
     * @param int - \Activity $value
     * @return \CDOTAUserMsg_UnitEvent\FadeGesture
     */
    public function setActivity( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_UnitEvent extends \DrSlump\Protobuf\Message {

    /**  @var int - \EDotaEntityMessages */
    public $msg_type = null;
    
    /**  @var int */
    public $entity_index = null;
    
    /**  @var \CDOTAUserMsg_UnitEvent\Speech */
    public $speech = null;
    
    /**  @var \CDOTAUserMsg_UnitEvent\SpeechMute */
    public $speech_mute = null;
    
    /**  @var \CDOTAUserMsg_UnitEvent\AddGesture */
    public $add_gesture = null;
    
    /**  @var \CDOTAUserMsg_UnitEvent\RemoveGesture */
    public $remove_gesture = null;
    
    /**  @var \CDOTAUserMsg_UnitEvent\BloodImpact */
    public $blood_impact = null;
    
    /**  @var \CDOTAUserMsg_UnitEvent\FadeGesture */
    public $fade_gesture = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_UnitEvent');

      // REQUIRED ENUM msg_type = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "msg_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_REQUIRED;
      $f->reference = '\EDotaEntityMessages';
      $descriptor->addField($f);

      // REQUIRED INT32 entity_index = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "entity_index";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_REQUIRED;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE speech = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "speech";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_UnitEvent\Speech';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE speech_mute = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "speech_mute";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_UnitEvent\SpeechMute';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE add_gesture = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "add_gesture";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_UnitEvent\AddGesture';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE remove_gesture = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "remove_gesture";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_UnitEvent\RemoveGesture';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE blood_impact = 7
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 7;
      $f->name      = "blood_impact";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_UnitEvent\BloodImpact';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE fade_gesture = 8
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 8;
      $f->name      = "fade_gesture";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_UnitEvent\FadeGesture';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <msg_type> has a value
     *
     * @return boolean
     */
    public function hasMsgType(){
      return $this->_has(1);
    }
    
    /**
     * Clear <msg_type> value
     *
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function clearMsgType(){
      return $this->_clear(1);
    }
    
    /**
     * Get <msg_type> value
     *
     * @return int - \EDotaEntityMessages
     */
    public function getMsgType(){
      return $this->_get(1);
    }
    
    /**
     * Set <msg_type> value
     *
     * @param int - \EDotaEntityMessages $value
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function setMsgType( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <entity_index> has a value
     *
     * @return boolean
     */
    public function hasEntityIndex(){
      return $this->_has(2);
    }
    
    /**
     * Clear <entity_index> value
     *
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function clearEntityIndex(){
      return $this->_clear(2);
    }
    
    /**
     * Get <entity_index> value
     *
     * @return int
     */
    public function getEntityIndex(){
      return $this->_get(2);
    }
    
    /**
     * Set <entity_index> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function setEntityIndex( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <speech> has a value
     *
     * @return boolean
     */
    public function hasSpeech(){
      return $this->_has(3);
    }
    
    /**
     * Clear <speech> value
     *
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function clearSpeech(){
      return $this->_clear(3);
    }
    
    /**
     * Get <speech> value
     *
     * @return \CDOTAUserMsg_UnitEvent\Speech
     */
    public function getSpeech(){
      return $this->_get(3);
    }
    
    /**
     * Set <speech> value
     *
     * @param \CDOTAUserMsg_UnitEvent\Speech $value
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function setSpeech(\CDOTAUserMsg_UnitEvent\Speech $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <speech_mute> has a value
     *
     * @return boolean
     */
    public function hasSpeechMute(){
      return $this->_has(4);
    }
    
    /**
     * Clear <speech_mute> value
     *
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function clearSpeechMute(){
      return $this->_clear(4);
    }
    
    /**
     * Get <speech_mute> value
     *
     * @return \CDOTAUserMsg_UnitEvent\SpeechMute
     */
    public function getSpeechMute(){
      return $this->_get(4);
    }
    
    /**
     * Set <speech_mute> value
     *
     * @param \CDOTAUserMsg_UnitEvent\SpeechMute $value
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function setSpeechMute(\CDOTAUserMsg_UnitEvent\SpeechMute $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <add_gesture> has a value
     *
     * @return boolean
     */
    public function hasAddGesture(){
      return $this->_has(5);
    }
    
    /**
     * Clear <add_gesture> value
     *
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function clearAddGesture(){
      return $this->_clear(5);
    }
    
    /**
     * Get <add_gesture> value
     *
     * @return \CDOTAUserMsg_UnitEvent\AddGesture
     */
    public function getAddGesture(){
      return $this->_get(5);
    }
    
    /**
     * Set <add_gesture> value
     *
     * @param \CDOTAUserMsg_UnitEvent\AddGesture $value
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function setAddGesture(\CDOTAUserMsg_UnitEvent\AddGesture $value){
      return $this->_set(5, $value);
    }
    
    /**
     * Check if <remove_gesture> has a value
     *
     * @return boolean
     */
    public function hasRemoveGesture(){
      return $this->_has(6);
    }
    
    /**
     * Clear <remove_gesture> value
     *
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function clearRemoveGesture(){
      return $this->_clear(6);
    }
    
    /**
     * Get <remove_gesture> value
     *
     * @return \CDOTAUserMsg_UnitEvent\RemoveGesture
     */
    public function getRemoveGesture(){
      return $this->_get(6);
    }
    
    /**
     * Set <remove_gesture> value
     *
     * @param \CDOTAUserMsg_UnitEvent\RemoveGesture $value
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function setRemoveGesture(\CDOTAUserMsg_UnitEvent\RemoveGesture $value){
      return $this->_set(6, $value);
    }
    
    /**
     * Check if <blood_impact> has a value
     *
     * @return boolean
     */
    public function hasBloodImpact(){
      return $this->_has(7);
    }
    
    /**
     * Clear <blood_impact> value
     *
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function clearBloodImpact(){
      return $this->_clear(7);
    }
    
    /**
     * Get <blood_impact> value
     *
     * @return \CDOTAUserMsg_UnitEvent\BloodImpact
     */
    public function getBloodImpact(){
      return $this->_get(7);
    }
    
    /**
     * Set <blood_impact> value
     *
     * @param \CDOTAUserMsg_UnitEvent\BloodImpact $value
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function setBloodImpact(\CDOTAUserMsg_UnitEvent\BloodImpact $value){
      return $this->_set(7, $value);
    }
    
    /**
     * Check if <fade_gesture> has a value
     *
     * @return boolean
     */
    public function hasFadeGesture(){
      return $this->_has(8);
    }
    
    /**
     * Clear <fade_gesture> value
     *
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function clearFadeGesture(){
      return $this->_clear(8);
    }
    
    /**
     * Get <fade_gesture> value
     *
     * @return \CDOTAUserMsg_UnitEvent\FadeGesture
     */
    public function getFadeGesture(){
      return $this->_get(8);
    }
    
    /**
     * Set <fade_gesture> value
     *
     * @param \CDOTAUserMsg_UnitEvent\FadeGesture $value
     * @return \CDOTAUserMsg_UnitEvent
     */
    public function setFadeGesture(\CDOTAUserMsg_UnitEvent\FadeGesture $value){
      return $this->_set(8, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_ItemPurchased extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $item_index = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ItemPurchased');

      // OPTIONAL INT32 item_index = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "item_index";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <item_index> has a value
     *
     * @return boolean
     */
    public function hasItemIndex(){
      return $this->_has(1);
    }
    
    /**
     * Clear <item_index> value
     *
     * @return \CDOTAUserMsg_ItemPurchased
     */
    public function clearItemIndex(){
      return $this->_clear(1);
    }
    
    /**
     * Get <item_index> value
     *
     * @return int
     */
    public function getItemIndex(){
      return $this->_get(1);
    }
    
    /**
     * Set <item_index> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ItemPurchased
     */
    public function setItemIndex( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_ItemFound extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $player = null;
    
    /**  @var int */
    public $quality = null;
    
    /**  @var int */
    public $rarity = null;
    
    /**  @var int */
    public $method = null;
    
    /**  @var int */
    public $itemdef = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ItemFound');

      // OPTIONAL INT32 player = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "player";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 quality = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "quality";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 rarity = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "rarity";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 method = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "method";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 itemdef = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "itemdef";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <player> has a value
     *
     * @return boolean
     */
    public function hasPlayer(){
      return $this->_has(1);
    }
    
    /**
     * Clear <player> value
     *
     * @return \CDOTAUserMsg_ItemFound
     */
    public function clearPlayer(){
      return $this->_clear(1);
    }
    
    /**
     * Get <player> value
     *
     * @return int
     */
    public function getPlayer(){
      return $this->_get(1);
    }
    
    /**
     * Set <player> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ItemFound
     */
    public function setPlayer( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <quality> has a value
     *
     * @return boolean
     */
    public function hasQuality(){
      return $this->_has(2);
    }
    
    /**
     * Clear <quality> value
     *
     * @return \CDOTAUserMsg_ItemFound
     */
    public function clearQuality(){
      return $this->_clear(2);
    }
    
    /**
     * Get <quality> value
     *
     * @return int
     */
    public function getQuality(){
      return $this->_get(2);
    }
    
    /**
     * Set <quality> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ItemFound
     */
    public function setQuality( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <rarity> has a value
     *
     * @return boolean
     */
    public function hasRarity(){
      return $this->_has(3);
    }
    
    /**
     * Clear <rarity> value
     *
     * @return \CDOTAUserMsg_ItemFound
     */
    public function clearRarity(){
      return $this->_clear(3);
    }
    
    /**
     * Get <rarity> value
     *
     * @return int
     */
    public function getRarity(){
      return $this->_get(3);
    }
    
    /**
     * Set <rarity> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ItemFound
     */
    public function setRarity( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <method> has a value
     *
     * @return boolean
     */
    public function hasMethod(){
      return $this->_has(4);
    }
    
    /**
     * Clear <method> value
     *
     * @return \CDOTAUserMsg_ItemFound
     */
    public function clearMethod(){
      return $this->_clear(4);
    }
    
    /**
     * Get <method> value
     *
     * @return int
     */
    public function getMethod(){
      return $this->_get(4);
    }
    
    /**
     * Set <method> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ItemFound
     */
    public function setMethod( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <itemdef> has a value
     *
     * @return boolean
     */
    public function hasItemdef(){
      return $this->_has(5);
    }
    
    /**
     * Clear <itemdef> value
     *
     * @return \CDOTAUserMsg_ItemFound
     */
    public function clearItemdef(){
      return $this->_clear(5);
    }
    
    /**
     * Get <itemdef> value
     *
     * @return int
     */
    public function getItemdef(){
      return $this->_get(5);
    }
    
    /**
     * Set <itemdef> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ItemFound
     */
    public function setItemdef( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class ReleaseParticleIndex extends \DrSlump\Protobuf\Message {


    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.ReleaseParticleIndex');

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class CreateParticle extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $particle_name_index = null;
    
    /**  @var int */
    public $attach_type = null;
    
    /**  @var int */
    public $entity_handle = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.CreateParticle');

      // OPTIONAL INT32 particle_name_index = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "particle_name_index";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 attach_type = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "attach_type";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 entity_handle = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "entity_handle";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <particle_name_index> has a value
     *
     * @return boolean
     */
    public function hasParticleNameIndex(){
      return $this->_has(1);
    }
    
    /**
     * Clear <particle_name_index> value
     *
     * @return \CDOTAUserMsg_ParticleManager\CreateParticle
     */
    public function clearParticleNameIndex(){
      return $this->_clear(1);
    }
    
    /**
     * Get <particle_name_index> value
     *
     * @return int
     */
    public function getParticleNameIndex(){
      return $this->_get(1);
    }
    
    /**
     * Set <particle_name_index> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\CreateParticle
     */
    public function setParticleNameIndex( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <attach_type> has a value
     *
     * @return boolean
     */
    public function hasAttachType(){
      return $this->_has(2);
    }
    
    /**
     * Clear <attach_type> value
     *
     * @return \CDOTAUserMsg_ParticleManager\CreateParticle
     */
    public function clearAttachType(){
      return $this->_clear(2);
    }
    
    /**
     * Get <attach_type> value
     *
     * @return int
     */
    public function getAttachType(){
      return $this->_get(2);
    }
    
    /**
     * Set <attach_type> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\CreateParticle
     */
    public function setAttachType( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <entity_handle> has a value
     *
     * @return boolean
     */
    public function hasEntityHandle(){
      return $this->_has(3);
    }
    
    /**
     * Clear <entity_handle> value
     *
     * @return \CDOTAUserMsg_ParticleManager\CreateParticle
     */
    public function clearEntityHandle(){
      return $this->_clear(3);
    }
    
    /**
     * Get <entity_handle> value
     *
     * @return int
     */
    public function getEntityHandle(){
      return $this->_get(3);
    }
    
    /**
     * Set <entity_handle> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\CreateParticle
     */
    public function setEntityHandle( $value){
      return $this->_set(3, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class DestroyParticle extends \DrSlump\Protobuf\Message {

    /**  @var boolean */
    public $destroy_immediately = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.DestroyParticle');

      // OPTIONAL BOOL destroy_immediately = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "destroy_immediately";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <destroy_immediately> has a value
     *
     * @return boolean
     */
    public function hasDestroyImmediately(){
      return $this->_has(1);
    }
    
    /**
     * Clear <destroy_immediately> value
     *
     * @return \CDOTAUserMsg_ParticleManager\DestroyParticle
     */
    public function clearDestroyImmediately(){
      return $this->_clear(1);
    }
    
    /**
     * Get <destroy_immediately> value
     *
     * @return boolean
     */
    public function getDestroyImmediately(){
      return $this->_get(1);
    }
    
    /**
     * Set <destroy_immediately> value
     *
     * @param boolean $value
     * @return \CDOTAUserMsg_ParticleManager\DestroyParticle
     */
    public function setDestroyImmediately( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class DestroyParticleInvolving extends \DrSlump\Protobuf\Message {

    /**  @var boolean */
    public $destroy_immediately = null;
    
    /**  @var int */
    public $entity_handle = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.DestroyParticleInvolving');

      // OPTIONAL BOOL destroy_immediately = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "destroy_immediately";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 entity_handle = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "entity_handle";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <destroy_immediately> has a value
     *
     * @return boolean
     */
    public function hasDestroyImmediately(){
      return $this->_has(1);
    }
    
    /**
     * Clear <destroy_immediately> value
     *
     * @return \CDOTAUserMsg_ParticleManager\DestroyParticleInvolving
     */
    public function clearDestroyImmediately(){
      return $this->_clear(1);
    }
    
    /**
     * Get <destroy_immediately> value
     *
     * @return boolean
     */
    public function getDestroyImmediately(){
      return $this->_get(1);
    }
    
    /**
     * Set <destroy_immediately> value
     *
     * @param boolean $value
     * @return \CDOTAUserMsg_ParticleManager\DestroyParticleInvolving
     */
    public function setDestroyImmediately( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <entity_handle> has a value
     *
     * @return boolean
     */
    public function hasEntityHandle(){
      return $this->_has(3);
    }
    
    /**
     * Clear <entity_handle> value
     *
     * @return \CDOTAUserMsg_ParticleManager\DestroyParticleInvolving
     */
    public function clearEntityHandle(){
      return $this->_clear(3);
    }
    
    /**
     * Get <entity_handle> value
     *
     * @return int
     */
    public function getEntityHandle(){
      return $this->_get(3);
    }
    
    /**
     * Set <entity_handle> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\DestroyParticleInvolving
     */
    public function setEntityHandle( $value){
      return $this->_set(3, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class UpdateParticle extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $control_point = null;
    
    /**  @var \CMsgVector */
    public $position = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.UpdateParticle');

      // OPTIONAL INT32 control_point = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "control_point";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE position = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "position";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <control_point> has a value
     *
     * @return boolean
     */
    public function hasControlPoint(){
      return $this->_has(1);
    }
    
    /**
     * Clear <control_point> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticle
     */
    public function clearControlPoint(){
      return $this->_clear(1);
    }
    
    /**
     * Get <control_point> value
     *
     * @return int
     */
    public function getControlPoint(){
      return $this->_get(1);
    }
    
    /**
     * Set <control_point> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticle
     */
    public function setControlPoint( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <position> has a value
     *
     * @return boolean
     */
    public function hasPosition(){
      return $this->_has(2);
    }
    
    /**
     * Clear <position> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticle
     */
    public function clearPosition(){
      return $this->_clear(2);
    }
    
    /**
     * Get <position> value
     *
     * @return \CMsgVector
     */
    public function getPosition(){
      return $this->_get(2);
    }
    
    /**
     * Set <position> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticle
     */
    public function setPosition(\CMsgVector $value){
      return $this->_set(2, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class UpdateParticleFwd extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $control_point = null;
    
    /**  @var \CMsgVector */
    public $forward = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.UpdateParticleFwd');

      // OPTIONAL INT32 control_point = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "control_point";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE forward = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "forward";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <control_point> has a value
     *
     * @return boolean
     */
    public function hasControlPoint(){
      return $this->_has(1);
    }
    
    /**
     * Clear <control_point> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFwd
     */
    public function clearControlPoint(){
      return $this->_clear(1);
    }
    
    /**
     * Get <control_point> value
     *
     * @return int
     */
    public function getControlPoint(){
      return $this->_get(1);
    }
    
    /**
     * Set <control_point> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFwd
     */
    public function setControlPoint( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <forward> has a value
     *
     * @return boolean
     */
    public function hasForward(){
      return $this->_has(2);
    }
    
    /**
     * Clear <forward> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFwd
     */
    public function clearForward(){
      return $this->_clear(2);
    }
    
    /**
     * Get <forward> value
     *
     * @return \CMsgVector
     */
    public function getForward(){
      return $this->_get(2);
    }
    
    /**
     * Set <forward> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFwd
     */
    public function setForward(\CMsgVector $value){
      return $this->_set(2, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class UpdateParticleOrient extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $control_point = null;
    
    /**  @var \CMsgVector */
    public $forward = null;
    
    /**  @var \CMsgVector */
    public $right = null;
    
    /**  @var \CMsgVector */
    public $up = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.UpdateParticleOrient');

      // OPTIONAL INT32 control_point = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "control_point";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE forward = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "forward";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE right = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "right";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE up = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "up";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <control_point> has a value
     *
     * @return boolean
     */
    public function hasControlPoint(){
      return $this->_has(1);
    }
    
    /**
     * Clear <control_point> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function clearControlPoint(){
      return $this->_clear(1);
    }
    
    /**
     * Get <control_point> value
     *
     * @return int
     */
    public function getControlPoint(){
      return $this->_get(1);
    }
    
    /**
     * Set <control_point> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function setControlPoint( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <forward> has a value
     *
     * @return boolean
     */
    public function hasForward(){
      return $this->_has(2);
    }
    
    /**
     * Clear <forward> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function clearForward(){
      return $this->_clear(2);
    }
    
    /**
     * Get <forward> value
     *
     * @return \CMsgVector
     */
    public function getForward(){
      return $this->_get(2);
    }
    
    /**
     * Set <forward> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function setForward(\CMsgVector $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <right> has a value
     *
     * @return boolean
     */
    public function hasRight(){
      return $this->_has(3);
    }
    
    /**
     * Clear <right> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function clearRight(){
      return $this->_clear(3);
    }
    
    /**
     * Get <right> value
     *
     * @return \CMsgVector
     */
    public function getRight(){
      return $this->_get(3);
    }
    
    /**
     * Set <right> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function setRight(\CMsgVector $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <up> has a value
     *
     * @return boolean
     */
    public function hasUp(){
      return $this->_has(4);
    }
    
    /**
     * Clear <up> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function clearUp(){
      return $this->_clear(4);
    }
    
    /**
     * Get <up> value
     *
     * @return \CMsgVector
     */
    public function getUp(){
      return $this->_get(4);
    }
    
    /**
     * Set <up> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function setUp(\CMsgVector $value){
      return $this->_set(4, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class UpdateParticleFallback extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $control_point = null;
    
    /**  @var \CMsgVector */
    public $position = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.UpdateParticleFallback');

      // OPTIONAL INT32 control_point = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "control_point";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE position = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "position";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <control_point> has a value
     *
     * @return boolean
     */
    public function hasControlPoint(){
      return $this->_has(1);
    }
    
    /**
     * Clear <control_point> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFallback
     */
    public function clearControlPoint(){
      return $this->_clear(1);
    }
    
    /**
     * Get <control_point> value
     *
     * @return int
     */
    public function getControlPoint(){
      return $this->_get(1);
    }
    
    /**
     * Set <control_point> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFallback
     */
    public function setControlPoint( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <position> has a value
     *
     * @return boolean
     */
    public function hasPosition(){
      return $this->_has(2);
    }
    
    /**
     * Clear <position> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFallback
     */
    public function clearPosition(){
      return $this->_clear(2);
    }
    
    /**
     * Get <position> value
     *
     * @return \CMsgVector
     */
    public function getPosition(){
      return $this->_get(2);
    }
    
    /**
     * Set <position> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFallback
     */
    public function setPosition(\CMsgVector $value){
      return $this->_set(2, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class UpdateParticleOffset extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $control_point = null;
    
    /**  @var \CMsgVector */
    public $origin_offset = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.UpdateParticleOffset');

      // OPTIONAL INT32 control_point = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "control_point";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE origin_offset = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "origin_offset";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <control_point> has a value
     *
     * @return boolean
     */
    public function hasControlPoint(){
      return $this->_has(1);
    }
    
    /**
     * Clear <control_point> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOffset
     */
    public function clearControlPoint(){
      return $this->_clear(1);
    }
    
    /**
     * Get <control_point> value
     *
     * @return int
     */
    public function getControlPoint(){
      return $this->_get(1);
    }
    
    /**
     * Set <control_point> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOffset
     */
    public function setControlPoint( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <origin_offset> has a value
     *
     * @return boolean
     */
    public function hasOriginOffset(){
      return $this->_has(2);
    }
    
    /**
     * Clear <origin_offset> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOffset
     */
    public function clearOriginOffset(){
      return $this->_clear(2);
    }
    
    /**
     * Get <origin_offset> value
     *
     * @return \CMsgVector
     */
    public function getOriginOffset(){
      return $this->_get(2);
    }
    
    /**
     * Set <origin_offset> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOffset
     */
    public function setOriginOffset(\CMsgVector $value){
      return $this->_set(2, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class UpdateParticleEnt extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $control_point = null;
    
    /**  @var int */
    public $entity_handle = null;
    
    /**  @var int */
    public $attach_type = null;
    
    /**  @var int */
    public $attachment = null;
    
    /**  @var \CMsgVector */
    public $fallback_position = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.UpdateParticleEnt');

      // OPTIONAL INT32 control_point = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "control_point";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 entity_handle = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "entity_handle";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 attach_type = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "attach_type";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 attachment = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "attachment";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE fallback_position = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "fallback_position";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CMsgVector';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <control_point> has a value
     *
     * @return boolean
     */
    public function hasControlPoint(){
      return $this->_has(1);
    }
    
    /**
     * Clear <control_point> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function clearControlPoint(){
      return $this->_clear(1);
    }
    
    /**
     * Get <control_point> value
     *
     * @return int
     */
    public function getControlPoint(){
      return $this->_get(1);
    }
    
    /**
     * Set <control_point> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function setControlPoint( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <entity_handle> has a value
     *
     * @return boolean
     */
    public function hasEntityHandle(){
      return $this->_has(2);
    }
    
    /**
     * Clear <entity_handle> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function clearEntityHandle(){
      return $this->_clear(2);
    }
    
    /**
     * Get <entity_handle> value
     *
     * @return int
     */
    public function getEntityHandle(){
      return $this->_get(2);
    }
    
    /**
     * Set <entity_handle> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function setEntityHandle( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <attach_type> has a value
     *
     * @return boolean
     */
    public function hasAttachType(){
      return $this->_has(3);
    }
    
    /**
     * Clear <attach_type> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function clearAttachType(){
      return $this->_clear(3);
    }
    
    /**
     * Get <attach_type> value
     *
     * @return int
     */
    public function getAttachType(){
      return $this->_get(3);
    }
    
    /**
     * Set <attach_type> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function setAttachType( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <attachment> has a value
     *
     * @return boolean
     */
    public function hasAttachment(){
      return $this->_has(4);
    }
    
    /**
     * Clear <attachment> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function clearAttachment(){
      return $this->_clear(4);
    }
    
    /**
     * Get <attachment> value
     *
     * @return int
     */
    public function getAttachment(){
      return $this->_get(4);
    }
    
    /**
     * Set <attachment> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function setAttachment( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <fallback_position> has a value
     *
     * @return boolean
     */
    public function hasFallbackPosition(){
      return $this->_has(5);
    }
    
    /**
     * Clear <fallback_position> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function clearFallbackPosition(){
      return $this->_clear(5);
    }
    
    /**
     * Get <fallback_position> value
     *
     * @return \CMsgVector
     */
    public function getFallbackPosition(){
      return $this->_get(5);
    }
    
    /**
     * Set <fallback_position> value
     *
     * @param \CMsgVector $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function setFallbackPosition(\CMsgVector $value){
      return $this->_set(5, $value);
    }
  }
}

namespace CDOTAUserMsg_ParticleManager {

  class UpdateParticleLatency extends \DrSlump\Protobuf\Message {

    /**  @var int */
    public $player_latency = null;
    
    /**  @var int */
    public $tick = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager.UpdateParticleLatency');

      // OPTIONAL INT32 player_latency = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "player_latency";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 tick = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "tick";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <player_latency> has a value
     *
     * @return boolean
     */
    public function hasPlayerLatency(){
      return $this->_has(1);
    }
    
    /**
     * Clear <player_latency> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleLatency
     */
    public function clearPlayerLatency(){
      return $this->_clear(1);
    }
    
    /**
     * Get <player_latency> value
     *
     * @return int
     */
    public function getPlayerLatency(){
      return $this->_get(1);
    }
    
    /**
     * Set <player_latency> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleLatency
     */
    public function setPlayerLatency( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <tick> has a value
     *
     * @return boolean
     */
    public function hasTick(){
      return $this->_has(2);
    }
    
    /**
     * Clear <tick> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleLatency
     */
    public function clearTick(){
      return $this->_clear(2);
    }
    
    /**
     * Get <tick> value
     *
     * @return int
     */
    public function getTick(){
      return $this->_get(2);
    }
    
    /**
     * Set <tick> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleLatency
     */
    public function setTick( $value){
      return $this->_set(2, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_ParticleManager extends \DrSlump\Protobuf\Message {

    /**  @var int - \DOTA_PARTICLE_MESSAGE */
    public $type = null;
    
    /**  @var int */
    public $index = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\ReleaseParticleIndex */
    public $release_particle_index = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\CreateParticle */
    public $create_particle = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\DestroyParticle */
    public $destroy_particle = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\DestroyParticleInvolving */
    public $destroy_particle_involving = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\UpdateParticle */
    public $update_particle = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\UpdateParticleFwd */
    public $update_particle_fwd = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\UpdateParticleOrient */
    public $update_particle_orient = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\UpdateParticleFallback */
    public $update_particle_fallback = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\UpdateParticleOffset */
    public $update_particle_offset = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\UpdateParticleEnt */
    public $update_particle_ent = null;
    
    /**  @var \CDOTAUserMsg_ParticleManager\UpdateParticleLatency */
    public $update_particle_latency = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_ParticleManager');

      // REQUIRED ENUM type = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_REQUIRED;
      $f->reference = '\DOTA_PARTICLE_MESSAGE';
      $descriptor->addField($f);

      // REQUIRED UINT32 index = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "index";
      $f->type      = \DrSlump\Protobuf::TYPE_UINT32;
      $f->rule      = \DrSlump\Protobuf::RULE_REQUIRED;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE release_particle_index = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "release_particle_index";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\ReleaseParticleIndex';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE create_particle = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "create_particle";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\CreateParticle';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE destroy_particle = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "destroy_particle";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\DestroyParticle';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE destroy_particle_involving = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "destroy_particle_involving";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\DestroyParticleInvolving';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE update_particle = 7
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 7;
      $f->name      = "update_particle";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\UpdateParticle';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE update_particle_fwd = 8
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 8;
      $f->name      = "update_particle_fwd";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\UpdateParticleFwd';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE update_particle_orient = 9
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 9;
      $f->name      = "update_particle_orient";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\UpdateParticleOrient';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE update_particle_fallback = 10
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 10;
      $f->name      = "update_particle_fallback";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\UpdateParticleFallback';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE update_particle_offset = 11
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 11;
      $f->name      = "update_particle_offset";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\UpdateParticleOffset';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE update_particle_ent = 12
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 12;
      $f->name      = "update_particle_ent";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\UpdateParticleEnt';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE update_particle_latency = 13
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 13;
      $f->name      = "update_particle_latency";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\CDOTAUserMsg_ParticleManager\UpdateParticleLatency';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <type> has a value
     *
     * @return boolean
     */
    public function hasType(){
      return $this->_has(1);
    }
    
    /**
     * Clear <type> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearType(){
      return $this->_clear(1);
    }
    
    /**
     * Get <type> value
     *
     * @return int - \DOTA_PARTICLE_MESSAGE
     */
    public function getType(){
      return $this->_get(1);
    }
    
    /**
     * Set <type> value
     *
     * @param int - \DOTA_PARTICLE_MESSAGE $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setType( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <index> has a value
     *
     * @return boolean
     */
    public function hasIndex(){
      return $this->_has(2);
    }
    
    /**
     * Clear <index> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearIndex(){
      return $this->_clear(2);
    }
    
    /**
     * Get <index> value
     *
     * @return int
     */
    public function getIndex(){
      return $this->_get(2);
    }
    
    /**
     * Set <index> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setIndex( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <release_particle_index> has a value
     *
     * @return boolean
     */
    public function hasReleaseParticleIndex(){
      return $this->_has(3);
    }
    
    /**
     * Clear <release_particle_index> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearReleaseParticleIndex(){
      return $this->_clear(3);
    }
    
    /**
     * Get <release_particle_index> value
     *
     * @return \CDOTAUserMsg_ParticleManager\ReleaseParticleIndex
     */
    public function getReleaseParticleIndex(){
      return $this->_get(3);
    }
    
    /**
     * Set <release_particle_index> value
     *
     * @param \CDOTAUserMsg_ParticleManager\ReleaseParticleIndex $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setReleaseParticleIndex(\CDOTAUserMsg_ParticleManager\ReleaseParticleIndex $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <create_particle> has a value
     *
     * @return boolean
     */
    public function hasCreateParticle(){
      return $this->_has(4);
    }
    
    /**
     * Clear <create_particle> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearCreateParticle(){
      return $this->_clear(4);
    }
    
    /**
     * Get <create_particle> value
     *
     * @return \CDOTAUserMsg_ParticleManager\CreateParticle
     */
    public function getCreateParticle(){
      return $this->_get(4);
    }
    
    /**
     * Set <create_particle> value
     *
     * @param \CDOTAUserMsg_ParticleManager\CreateParticle $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setCreateParticle(\CDOTAUserMsg_ParticleManager\CreateParticle $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <destroy_particle> has a value
     *
     * @return boolean
     */
    public function hasDestroyParticle(){
      return $this->_has(5);
    }
    
    /**
     * Clear <destroy_particle> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearDestroyParticle(){
      return $this->_clear(5);
    }
    
    /**
     * Get <destroy_particle> value
     *
     * @return \CDOTAUserMsg_ParticleManager\DestroyParticle
     */
    public function getDestroyParticle(){
      return $this->_get(5);
    }
    
    /**
     * Set <destroy_particle> value
     *
     * @param \CDOTAUserMsg_ParticleManager\DestroyParticle $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setDestroyParticle(\CDOTAUserMsg_ParticleManager\DestroyParticle $value){
      return $this->_set(5, $value);
    }
    
    /**
     * Check if <destroy_particle_involving> has a value
     *
     * @return boolean
     */
    public function hasDestroyParticleInvolving(){
      return $this->_has(6);
    }
    
    /**
     * Clear <destroy_particle_involving> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearDestroyParticleInvolving(){
      return $this->_clear(6);
    }
    
    /**
     * Get <destroy_particle_involving> value
     *
     * @return \CDOTAUserMsg_ParticleManager\DestroyParticleInvolving
     */
    public function getDestroyParticleInvolving(){
      return $this->_get(6);
    }
    
    /**
     * Set <destroy_particle_involving> value
     *
     * @param \CDOTAUserMsg_ParticleManager\DestroyParticleInvolving $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setDestroyParticleInvolving(\CDOTAUserMsg_ParticleManager\DestroyParticleInvolving $value){
      return $this->_set(6, $value);
    }
    
    /**
     * Check if <update_particle> has a value
     *
     * @return boolean
     */
    public function hasUpdateParticle(){
      return $this->_has(7);
    }
    
    /**
     * Clear <update_particle> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearUpdateParticle(){
      return $this->_clear(7);
    }
    
    /**
     * Get <update_particle> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticle
     */
    public function getUpdateParticle(){
      return $this->_get(7);
    }
    
    /**
     * Set <update_particle> value
     *
     * @param \CDOTAUserMsg_ParticleManager\UpdateParticle $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setUpdateParticle(\CDOTAUserMsg_ParticleManager\UpdateParticle $value){
      return $this->_set(7, $value);
    }
    
    /**
     * Check if <update_particle_fwd> has a value
     *
     * @return boolean
     */
    public function hasUpdateParticleFwd(){
      return $this->_has(8);
    }
    
    /**
     * Clear <update_particle_fwd> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearUpdateParticleFwd(){
      return $this->_clear(8);
    }
    
    /**
     * Get <update_particle_fwd> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFwd
     */
    public function getUpdateParticleFwd(){
      return $this->_get(8);
    }
    
    /**
     * Set <update_particle_fwd> value
     *
     * @param \CDOTAUserMsg_ParticleManager\UpdateParticleFwd $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setUpdateParticleFwd(\CDOTAUserMsg_ParticleManager\UpdateParticleFwd $value){
      return $this->_set(8, $value);
    }
    
    /**
     * Check if <update_particle_orient> has a value
     *
     * @return boolean
     */
    public function hasUpdateParticleOrient(){
      return $this->_has(9);
    }
    
    /**
     * Clear <update_particle_orient> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearUpdateParticleOrient(){
      return $this->_clear(9);
    }
    
    /**
     * Get <update_particle_orient> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOrient
     */
    public function getUpdateParticleOrient(){
      return $this->_get(9);
    }
    
    /**
     * Set <update_particle_orient> value
     *
     * @param \CDOTAUserMsg_ParticleManager\UpdateParticleOrient $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setUpdateParticleOrient(\CDOTAUserMsg_ParticleManager\UpdateParticleOrient $value){
      return $this->_set(9, $value);
    }
    
    /**
     * Check if <update_particle_fallback> has a value
     *
     * @return boolean
     */
    public function hasUpdateParticleFallback(){
      return $this->_has(10);
    }
    
    /**
     * Clear <update_particle_fallback> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearUpdateParticleFallback(){
      return $this->_clear(10);
    }
    
    /**
     * Get <update_particle_fallback> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleFallback
     */
    public function getUpdateParticleFallback(){
      return $this->_get(10);
    }
    
    /**
     * Set <update_particle_fallback> value
     *
     * @param \CDOTAUserMsg_ParticleManager\UpdateParticleFallback $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setUpdateParticleFallback(\CDOTAUserMsg_ParticleManager\UpdateParticleFallback $value){
      return $this->_set(10, $value);
    }
    
    /**
     * Check if <update_particle_offset> has a value
     *
     * @return boolean
     */
    public function hasUpdateParticleOffset(){
      return $this->_has(11);
    }
    
    /**
     * Clear <update_particle_offset> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearUpdateParticleOffset(){
      return $this->_clear(11);
    }
    
    /**
     * Get <update_particle_offset> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleOffset
     */
    public function getUpdateParticleOffset(){
      return $this->_get(11);
    }
    
    /**
     * Set <update_particle_offset> value
     *
     * @param \CDOTAUserMsg_ParticleManager\UpdateParticleOffset $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setUpdateParticleOffset(\CDOTAUserMsg_ParticleManager\UpdateParticleOffset $value){
      return $this->_set(11, $value);
    }
    
    /**
     * Check if <update_particle_ent> has a value
     *
     * @return boolean
     */
    public function hasUpdateParticleEnt(){
      return $this->_has(12);
    }
    
    /**
     * Clear <update_particle_ent> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearUpdateParticleEnt(){
      return $this->_clear(12);
    }
    
    /**
     * Get <update_particle_ent> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleEnt
     */
    public function getUpdateParticleEnt(){
      return $this->_get(12);
    }
    
    /**
     * Set <update_particle_ent> value
     *
     * @param \CDOTAUserMsg_ParticleManager\UpdateParticleEnt $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setUpdateParticleEnt(\CDOTAUserMsg_ParticleManager\UpdateParticleEnt $value){
      return $this->_set(12, $value);
    }
    
    /**
     * Check if <update_particle_latency> has a value
     *
     * @return boolean
     */
    public function hasUpdateParticleLatency(){
      return $this->_has(13);
    }
    
    /**
     * Clear <update_particle_latency> value
     *
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function clearUpdateParticleLatency(){
      return $this->_clear(13);
    }
    
    /**
     * Get <update_particle_latency> value
     *
     * @return \CDOTAUserMsg_ParticleManager\UpdateParticleLatency
     */
    public function getUpdateParticleLatency(){
      return $this->_get(13);
    }
    
    /**
     * Set <update_particle_latency> value
     *
     * @param \CDOTAUserMsg_ParticleManager\UpdateParticleLatency $value
     * @return \CDOTAUserMsg_ParticleManager
     */
    public function setUpdateParticleLatency(\CDOTAUserMsg_ParticleManager\UpdateParticleLatency $value){
      return $this->_set(13, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_OverheadEvent extends \DrSlump\Protobuf\Message {

    /**  @var int - \DOTA_OVERHEAD_ALERT */
    public $message_type = null;
    
    /**  @var int */
    public $value = null;
    
    /**  @var int */
    public $target_player_entindex = null;
    
    /**  @var int */
    public $target_entindex = null;
    
    /**  @var int */
    public $source_player_entindex = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_OverheadEvent');

      // REQUIRED ENUM message_type = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "message_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_REQUIRED;
      $f->reference = '\DOTA_OVERHEAD_ALERT';
      $descriptor->addField($f);

      // OPTIONAL INT32 value = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "value";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 target_player_entindex = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "target_player_entindex";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 target_entindex = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "target_entindex";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 source_player_entindex = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "source_player_entindex";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <message_type> has a value
     *
     * @return boolean
     */
    public function hasMessageType(){
      return $this->_has(1);
    }
    
    /**
     * Clear <message_type> value
     *
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function clearMessageType(){
      return $this->_clear(1);
    }
    
    /**
     * Get <message_type> value
     *
     * @return int - \DOTA_OVERHEAD_ALERT
     */
    public function getMessageType(){
      return $this->_get(1);
    }
    
    /**
     * Set <message_type> value
     *
     * @param int - \DOTA_OVERHEAD_ALERT $value
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function setMessageType( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <value> has a value
     *
     * @return boolean
     */
    public function hasValue(){
      return $this->_has(2);
    }
    
    /**
     * Clear <value> value
     *
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function clearValue(){
      return $this->_clear(2);
    }
    
    /**
     * Get <value> value
     *
     * @return int
     */
    public function getValue(){
      return $this->_get(2);
    }
    
    /**
     * Set <value> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function setValue( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <target_player_entindex> has a value
     *
     * @return boolean
     */
    public function hasTargetPlayerEntindex(){
      return $this->_has(3);
    }
    
    /**
     * Clear <target_player_entindex> value
     *
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function clearTargetPlayerEntindex(){
      return $this->_clear(3);
    }
    
    /**
     * Get <target_player_entindex> value
     *
     * @return int
     */
    public function getTargetPlayerEntindex(){
      return $this->_get(3);
    }
    
    /**
     * Set <target_player_entindex> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function setTargetPlayerEntindex( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <target_entindex> has a value
     *
     * @return boolean
     */
    public function hasTargetEntindex(){
      return $this->_has(4);
    }
    
    /**
     * Clear <target_entindex> value
     *
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function clearTargetEntindex(){
      return $this->_clear(4);
    }
    
    /**
     * Get <target_entindex> value
     *
     * @return int
     */
    public function getTargetEntindex(){
      return $this->_get(4);
    }
    
    /**
     * Set <target_entindex> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function setTargetEntindex( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <source_player_entindex> has a value
     *
     * @return boolean
     */
    public function hasSourcePlayerEntindex(){
      return $this->_has(5);
    }
    
    /**
     * Clear <source_player_entindex> value
     *
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function clearSourcePlayerEntindex(){
      return $this->_clear(5);
    }
    
    /**
     * Get <source_player_entindex> value
     *
     * @return int
     */
    public function getSourcePlayerEntindex(){
      return $this->_get(5);
    }
    
    /**
     * Set <source_player_entindex> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_OverheadEvent
     */
    public function setSourcePlayerEntindex( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace  {

  class CDOTAUserMsg_TutorialTipInfo extends \DrSlump\Protobuf\Message {

    /**  @var string */
    public $name = null;
    
    /**  @var int */
    public $progress = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.CDOTAUserMsg_TutorialTipInfo');

      // OPTIONAL STRING name = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "name";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT32 progress = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "progress";
      $f->type      = \DrSlump\Protobuf::TYPE_INT32;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <name> has a value
     *
     * @return boolean
     */
    public function hasName(){
      return $this->_has(1);
    }
    
    /**
     * Clear <name> value
     *
     * @return \CDOTAUserMsg_TutorialTipInfo
     */
    public function clearName(){
      return $this->_clear(1);
    }
    
    /**
     * Get <name> value
     *
     * @return string
     */
    public function getName(){
      return $this->_get(1);
    }
    
    /**
     * Set <name> value
     *
     * @param string $value
     * @return \CDOTAUserMsg_TutorialTipInfo
     */
    public function setName( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <progress> has a value
     *
     * @return boolean
     */
    public function hasProgress(){
      return $this->_has(2);
    }
    
    /**
     * Clear <progress> value
     *
     * @return \CDOTAUserMsg_TutorialTipInfo
     */
    public function clearProgress(){
      return $this->_clear(2);
    }
    
    /**
     * Get <progress> value
     *
     * @return int
     */
    public function getProgress(){
      return $this->_get(2);
    }
    
    /**
     * Set <progress> value
     *
     * @param int $value
     * @return \CDOTAUserMsg_TutorialTipInfo
     */
    public function setProgress( $value){
      return $this->_set(2, $value);
    }
  }
}

